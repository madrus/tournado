---
description: Architectural Decision Records
globs:
alwaysApply: false
---

# Architecture Decision Records

## Decision Registry

<!-- BEGIN:ADR_INDEX -->

| ID   | Title                                                                       | Date       | Status   | Supersedes | Superseded by |
| ---- | --------------------------------------------------------------------------- | ---------- | -------- | ---------- | ------------- |
| 0001 | [React Router v7 Frontend Architecture](#adr-0001)                          | 2025-08-27 | Accepted | —          | —             |
| 0002 | [Single Repository Frontend-Only Architecture](#adr-0002)                   | 2025-08-27 | Accepted | —          | —             |
| 0003 | [State Management with Zustand and React Router Loaders](#adr-0003)         | 2025-08-27 | Accepted | —          | —             |
| 0004 | [Authentication via Firebase with Session Cookie Bridging](#adr-0004)       | 2025-09-03 | Accepted | —          | —             |
| 0005 | [Role-Based Access Control and Referee Token System](#adr-0005)             | 2025-09-03 | Accepted | —          | —             |
| 0006 | [Design System: Semantic Tokens and Dark Mode](#adr-0006)                   | 2025-09-03 | Accepted | —          | —             |
| 0007 | [Navigation Performance: Prefetching and Data Freshness](#adr-0007)         | 2025-09-03 | Accepted | —          | —             |
| 0008 | [Service Worker and PWA Capabilities](#adr-0008)                            | 2025-09-03 | Accepted | —          | —             |
| 0009 | [Internationalization Persistence and SSR Detection](#adr-0009)             | 2025-09-03 | Accepted | —          | —             |
| 0010 | [CI/CD and Fly.io Deployment Strategy](#adr-0010)                           | 2025-09-03 | Accepted | —          | —             |
| 0011 | [Security Headers and CSP Baseline](#adr-0011)                              | 2025-09-03 | Accepted | —          | —             |
| 0012 | [Analytics and Privacy (GA4 Scope)](#adr-0012)                              | 2025-09-03 | Accepted | —          | —             |
| 0013 | [Testing Strategy and Comprehensive Coverage](#adr-0013)                    | 2025-09-05 | Accepted | —          | —             |
| 0014 | [Mobile-First Responsive Design Strategy](#adr-0014)                        | 2025-09-05 | Accepted | —          | —             |
| 0015 | [Error Handling and Boundaries Architecture](#adr-0015)                     | 2025-09-05 | Accepted | —          | —             |
| 0016 | [Performance Architecture: Bundle Management and Code Splitting](#adr-0016) | 2025-09-05 | Accepted | —          | —             |
| 0017 | [Email Integration via Resend](#adr-0017)                                   | 2025-09-05 | Accepted | —          | —             |
| 0018 | [Rate Limiting and Security Middleware](#adr-0018)                          | 2025-09-05 | Accepted | —          | —             |
| 0019 | [Data Model and Migration Strategy](#adr-0019)                              | 2025-09-05 | Accepted | —          | —             |
| 0020 | [Offline Capabilities and Background Sync](#adr-0020)                       | 2025-09-05 | Accepted | —          | —             |
| 0021 | [Live Updates Transport Architecture](#adr-0021)                            | 2025-09-05 | Accepted | —          | —             |
| 0022 | [RBAC Middleware and Permission Utilities](#adr-0022)                       | 2025-09-07 | Accepted | —          | —             |
| 0023 | [Environment Variable Management Strategy](#adr-0023)                       | 2025-09-21 | Accepted | —          | —             |
| 0024 | [E2E Testing Firebase Bypass Strategy](#adr-0024)                           | 2025-09-21 | Accepted | —          | —             |
| 0025 | [Competition Section Structure and Group Management](#adr-0025)             | 2025-10-08 | Accepted | —          | —             |
| 0026 | [User Management Workflows and Admin Controls](#adr-0026)                  | 2025-10-08 | Implemented | —          | —             |
| 0027 | [Semantic Heading Hierarchy with AppBar h1](#adr-0027)                     | 2025-10-24 | Accepted | —          | —             |

<!-- END:ADR_INDEX -->

## ADR-0001 — React Router v7 Frontend Architecture

<a id="adr-0001"></a>
**Date**: 2025-08-27
**Status**: Accepted
**Owner**: André Roussakoff

### Context

Modern tournament management applications require responsive, offline-capable frontend experiences with efficient data management. React Router v7 provides full-stack capabilities with SSR, while Prisma and SQLite offer robust data persistence without backend complexity.

### Alternatives

- **Create React App**: Basic setup but lacks SSR and advanced routing capabilities
- **Next.js**: Full-stack but adds unnecessary complexity for frontend-focused applications
- **Vite + React Router (classic)**: Client-side only, missing SSR benefits
- **React Router v7**: Modern full-stack React framework with file-based routing and SSR

### Decision

Create a comprehensive React Router v7 frontend architecture with:

- React Router v7 with file-based routing and SSR
- TypeScript for type safety throughout the application
- Prisma ORM with SQLite for data persistence
- Tailwind CSS for responsive, mobile-first design
- Vite as build tool for optimal performance
- Zustand for client-side state management

### Consequences

- **Pros**: Modern React patterns, excellent performance, simplified architecture, type-safe development
- **Cons / risks**: Relatively new framework, fewer third-party integrations, learning curve for team
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

Template includes working examples for routing, data loading, and state management. Development workflow optimized for React Router v7 patterns. Testing strategy covers both unit and E2E scenarios.

## ADR-0002 — Single Repository Frontend-Only Architecture

<a id="adr-0002"></a>
**Date**: 2025-08-27
**Status**: Accepted
**Owner**: André Roussakoff

### Context

Tournament management applications can be effectively built as frontend-only applications using React Router v7's full-stack capabilities. The decision was how to structure the codebase to maximize development efficiency while maintaining clear organization.

### Alternatives

- **Monorepo with separate frontend/backend**: Unnecessary complexity for frontend-only architecture
- **Nested component directories**: Harder to navigate and maintain as application grows
- **Single repository with feature-based organization**: Clean structure optimized for React Router v7

### Decision

Implement single repository structure optimized for React Router v7:

- `/app/` - Main application code with routes, components, and utilities
- `/app/routes/` - File-based routing structure following React Router v7 conventions
- `/app/components/` - Reusable UI components organized by domain
- `/prisma/` - Database schema and migrations
- Root-level configuration files (Vite, Tailwind, TypeScript, etc.)
- `/docs/` - Comprehensive documentation system

### Consequences

- **Pros**: Simplified development workflow, single deployment target, clear React Router patterns, easier maintenance
- **Cons / risks**: All code in single repository, potential for large bundle sizes without proper code splitting
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

Directory structure follows React Router v7 conventions. Build system optimized for single-page application deployment. Documentation covers development patterns and best practices.

## ADR-0003 — State Management with Zustand and React Router Loaders

<a id="adr-0003"></a>
**Date**: 2025-08-27
**Status**: Accepted
**Owner**: André Roussakoff

### Context

Frontend applications need efficient state management that works well with React Router v7's data loading patterns. The challenge is balancing server-side data loading with client-side state management while maintaining type safety and performance.

### Alternatives

- **Redux Toolkit**: Comprehensive but adds complexity and boilerplate for frontend-only applications
- **React Context only**: Simple but can cause performance issues with large state trees
- **SWR/React Query**: Great for server state but requires separate client state solution
- **Zustand with React Router loaders**: Lightweight client state with built-in server data management

### Decision

Implement hybrid state management combining Zustand for client state with React Router loaders for server data:

- React Router loaders handle all server data fetching and caching
- Zustand stores manage client-only state (UI state, user preferences, temporary data)
- Server state flows through React Router's built-in data loading mechanisms
- Client state persists using Zustand's persistence middleware where appropriate
- Type-safe state management throughout the application

### Consequences

- **Pros**: Optimal performance, minimal boilerplate, leverages React Router's caching, type-safe state management, clear separation between server and client state
- **Cons / risks**: Learning curve for developers familiar with Redux, need to understand React Router data patterns, potential over-fetching without careful loader design
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

Server data must flow through React Router loaders and actions. Client state management uses Zustand with proper TypeScript interfaces. No direct API calls from components except through loader/action patterns. State persistence configured only for appropriate client state.

## ADR-0004 — Authentication via Firebase with Session Cookie Bridging

<a id="adr-0004"></a>
**Date**: 2025-09-03
**Status**: Accepted
**Owner**: André Roussakoff

### Context

We are replacing bespoke cookie-based authentication with Firebase Authentication to support Google SSO and optional email/password while maintaining SSR and role checks.

### Alternatives

- Continue bespoke auth with session cookies (no SSO, more maintenance)
- Store Firebase ID tokens in localStorage (security risk, no SSR integration)
- OAuth-only (no email/password option)

### Decision

Adopt Firebase Authentication and mint HTTP-only session cookies on the server from Firebase ID tokens (session cookie bridging). Maintain SSR-friendly role checks and post-login role-based redirects. Avoid long-lived tokens in localStorage; use short-lived in-memory tokens where necessary.

**Environment Separation Strategy** (Updated 2025-09-21):
- **CI Environment**: Uses dummy Firebase values (`ci-dummy-project`) for E2E testing with authentication bypass
- **Staging Environment**: Uses dedicated `tournado-dev` Firebase project for development and testing
- **Production Environment**: Uses dedicated `tournado-prod` Firebase project for live application
- **Security Isolation**: Each environment has separate Firebase service accounts with minimal required permissions

### Consequences

* Pros: Strong security posture, SSO support, SSR compatibility, unified auth flows
* Cons / risks: Migration effort, bridging complexity, dual-mode support during rollout
* Supersedes: —
* Superseded by: —

### Compliance / Verification

End-to-end tests cover sign-in/out, redirects, and loader-based role verification. Logout invalidates Firebase session cookies and client state.

**Implementation Status**: Firebase Authentication is implemented end-to-end:

- TASK-0101: Firebase setup — done
- TASK-0102: Session bridging — done (SSR-compatible session cookies)
- TASK-0103: Google OAuth UX — done
- TASK-0104: Email/Password authentication — done
- TASK-0105: Environment separation — done (CI/staging/production isolation)
- TASK-0106: Legacy authentication removal — done (bcrypt/Password table removed)

Production code is kept clean while tests and E2E run via adapters:

- Client adapters encapsulate mock-aware auth functions (no Playwright checks in hooks/components)
- Redirect adapter submits form in E2E to ensure cookie + redirect semantics
- Server token verification supports mock tokens behind `x-test-bypass` header only (no production paths affected)

The application is now Firebase-only with no legacy authentication dependencies.

**Future Consideration**: Phone number authentication evaluated but postponed due to SMS costs, regional reliability concerns, and security risks. Complete technical implementation documented in `docs/development/authentication.md` for future evaluation pending user demand or international expansion requirements.

## ADR-0005 — Role-Based Access Control and Referee Token System

<a id="adr-0005"></a>
**Date**: 2025-09-03
**Status**: Accepted
**Owner**: André Roussakoff

### Context

We need a comprehensive RBAC system with role hierarchy, permission matrix, secure middleware for route protection, and a referee token system for match-scoped access without user accounts.

### Alternatives

- Coarse admin/non-admin split (insufficient granularity)
- Client-only role checks (not secure)
- Manual URL parsing for self-access (vulnerable)
- Regular user accounts for referees (unnecessary complexity)

### Decision

Define roles: PUBLIC, REFEREE, MANAGER, ADMIN, EDITOR (future), BILLING (future). Inheritance: PUBLIC < REFEREE < MANAGER < ADMIN. Use permission-based middleware `requireUserWithPermission(request, permission, { allowSelfAccess, userIdParam, params })` in loaders/actions.

**RBAC Matrix**:
- PUBLIC: teams:read, tournaments:read, matches:read, teams:create (public registration)
- REFEREE: PUBLIC + matches:referee, matches:edit (assigned only)
- MANAGER: PUBLIC + teams:*, tournaments:*, matches:*, groups:manage, referees:assign, assignments:manage, refereeTokens:manage
- ADMIN: all permissions (*) including users:approve, roles:assign

**Referee Token System**: Managers issue pre-authenticated, expiring links scoped to tournament and assigned matches. Referees access dedicated dashboard via tokens without user accounts. Tokens are revocable and include tournamentId, matchIds scope, expiry, and issuer tracking.

**Panel Access**: Admin Panel access for ADMIN/MANAGER (full), REFEREE (scoped dashboard only, no general navigation). Use route `params` for self-access checks.

### Consequences

* Pros: Granular access, defense-in-depth, testable enforcement, simplified referee workflow, admin control over user approval/roles
* Cons / risks: Matrix maintenance, token management complexity, migration effort
* Supersedes: —
* Superseded by: —

### Compliance / Verification

Playwright role projects test panel access and feature visibility. Unit tests validate permission matrix, self-access logic, and token scoping. E2E tests verify referee dashboard isolation and token lifecycle.

## ADR-0006 — Design System: Semantic Tokens and Dark Mode

<a id="adr-0006"></a>
**Date**: 2025-09-03
**Status**: Accepted
**Owner**: André Roussakoff

### Context

We need consistent theming with light/dark modes, 20+ color accents, and accessible contrast, while avoiding hard-coded colors.

### Alternatives

- Hard-coded Tailwind colors per component (duplication, inconsistency)
- Conditional theme logic in components (fragile, hard to maintain)
- Minimal token usage (insufficient coverage)

### Decision

Adopt semantic CSS tokens mapped in Tailwind, CVA-based component variants for accents, and a ThemeToggle. Icons inherit `currentColor`. Enforce WCAG 2.1 AA contrast and visible focus rings. No hard-coded colors; components remain theme-agnostic.

### Consequences

* Pros: Consistency, accessibility, easy theming, smaller duplication
* Cons / risks: Initial refactor effort, need for contributor discipline
* Supersedes: —
* Superseded by: —

### Compliance / Verification

- Visual checks for light/dark, linting/guidelines, and tests for theme states on critical components
- Accessibility checks ensure animations stay comfortable for people who choose reduced motion settings

## ADR-0007 — Navigation Performance: Prefetching and Data Freshness

<a id="adr-0007"></a>
**Date**: 2025-09-03
**Status**: Accepted
**Owner**: André Roussakoff

### Context

We want fast navigation without bandwidth waste and must avoid stale lists when using browser back/forward.

### Alternatives

- No prefetching (slower navigation)
- Always prefetch aggressively (wasted bandwidth, battery)
- Custom caching logic (complexity)

### Decision

Use context-based prefetching: `intent` for navigation links, `render` for CTAs/pagination, `viewport` selectively. Enable adaptive behavior on slow/data-saver/mobile. On teams/tournaments list pages, revalidate on `popstate` using `useRevalidator()`.

### Consequences

* Pros: Snappy UX, controlled overhead, better mobile performance
* Cons / risks: More configuration surface, need to monitor analytics
* Supersedes: —
* Superseded by: —

### Compliance / Verification

Track cache hit rates and navigation timings. Verify revalidation triggers on back/forward in tests.

## ADR-0008 — Service Worker and PWA Capabilities

<a id="adr-0008"></a>
**Date**: 2025-09-03
**Status**: Accepted
**Owner**: André Roussakoff

### Context

We need PWA capabilities including offline scoring for referees, background sync, update prompts, and controlled logging for debugging production issues.

### Alternatives

- No service worker (lose offline capabilities)
- Full offline-first architecture (scope creep, complexity)
- Always-on verbose logging (noisy, risky)
- Manual refresh prompts (poor UX)

### Decision

Implement comprehensive PWA capabilities with:

**Service Worker Features**:
- `SW_DEBUG` flag for controlled logging (disabled in production)
- Offline scoring queues with background sync for referee score submission
- Update prompts and background sync for app updates
- Selective route/data caching with cache strategies per route type
- Add-to-home-screen prompts with proper manifest configuration

**Offline Strategy**:
- Critical referee flows work offline with visible pending state
- Background sync with exponential backoff retry logic
- Conflict resolution UI when server state changes during offline period
- IndexedDB for persistent offline data storage

**Update Management**:
- Background app updates with user-friendly update prompts
- Service worker lifecycle management with proper activation
- Cache invalidation strategies for schema/API changes

### Consequences

* Pros: Reliable referee scoring offline, better mobile experience, professional PWA features, controlled debugging
* Cons / risks: Service worker complexity, offline sync conflict handling, testing complexity
* Supersedes: —
* Superseded by: —

### Compliance / Verification

E2E tests verify offline scoring workflow and conflict resolution. Service worker update flow tested across versions. CI checks ensure `SW_DEBUG` disabled in production builds.

## ADR-0009 — Internationalization Persistence and SSR Detection

<a id="adr-0009"></a>
**Date**: 2025-09-03
**Status**: Accepted
**Owner**: André Roussakoff

### Context

The app supports multiple languages (nl, en, fr, ar, tr, de). We need SSR-aware language detection and reliable persistence.

### Alternatives

- LocalStorage-only persistence (not SSR-aware)
- Query param only (fragile)
- Browser default only (no explicit persistence)

### Decision

Persist language in cookie + localStorage reactively. Read language from cookie on the server during initial request. Use `nl` as fallback. Centralize supported language enumeration for easier maintenance.

**Server-Side Translation Support** (Added 2025-11-02):
- Server actions and loaders can use `getServerT(request)` to get translation function bound to user's language
- Language detection via `getLanguageFromRequest(request)` extracts language from cookie with fallback to Dutch
- Enables localized error messages and server-generated content in user's preferred language
- Uses `SUPPORTED_LANGUAGE_CODES` for validation (derived from `SUPPORTED_LANGUAGES`)

Implementation references:
- Eager config: `app/i18n/config.ts` (fallbackLng: `nl`, `SUPPORTED_LANGUAGES`, `SUPPORTED_LANGUAGE_CODES`)
- Server utilities: `app/i18n/i18n.server.ts` (`getLanguageFromRequest`, `getServerT`)
- Lazy config: `app/i18n/config.lazy.ts` (on-demand locale loading, caching)
- Cache utilities: `app/i18n/cache.ts`

### Consequences

* Pros: SSR compatibility, consistent UX across sessions, easy language management, server-side translations in user's language
* Cons / risks: Keep enum and translation files in sync, cookie handling, server-side translation key maintenance
* Supersedes: —
* Superseded by: —

### Compliance / Verification

Loader reads cookie; root updates cookie/localStorage on change. Server actions use `getServerT(request)` for localized messages. Tests verify SSR language detection, client persistence, and server-side translation accuracy.

## ADR-0010 — CI/CD and Fly.io Deployment Strategy

<a id="adr-0010"></a>
**Date**: 2025-09-03
**Status**: Accepted
**Owner**: André Roussakoff

### Context

We deploy via Fly.io with GitHub Actions and notify via Slack. We want a clear branch→environment mapping, rollback strategy, and comprehensive secrets management.

### Alternatives

- Manual deploys only (inconsistent)
- Single environment (no staging)
- Multiple cloud targets (complexity)

### Decision

Define CI/CD workflow with branch→app mapping and explicit secrets:

**Branch Mapping**:
- `dev` → staging app, `main` → production app

**Fly Apps**:
- Staging: `tournado-staging` (host: `tournado-staging.fly.io`)
- Production: `tournado` (host: `tournado.fly.io`)

**GitHub Actions**:
- Deploy on push to `dev` and `main`
- Secrets in GitHub: `FLY_API_TOKEN` (required), `SLACK_WEBHOOK_URL` (optional)
- CI runs lint, typecheck, unit, and E2E before deploy

**Fly App Secrets (per environment)**:
- `SESSION_SECRET` (required for cookie sessions)
- `DATABASE_URL`:
  - Local dev: `file:./prisma/data.db?connection_limit=1`
  - Test DB: `file:./prisma/data-test.db?connection_limit=1`
  - Production: `file:/data/sqlite.db?connection_limit=1`
- `RESEND_API_KEY` (email integration)
- `EMAIL_FROM` (e.g., `Team Registration <onboarding@resend.dev>`)
- `BASE_URL` (environment-specific email link base)
  - Local dev: `http://localhost:5173`
  - Staging: `https://tournado-staging.fly.io`
  - Production: `https://tournado.fly.io`

**Firebase Configuration (Vite environment)**:
- `VITE_FIREBASE_API_KEY`
- `VITE_FIREBASE_AUTH_DOMAIN`
- `VITE_FIREBASE_PROJECT_ID`
- `VITE_FIREBASE_STORAGE_BUCKET`
- `VITE_FIREBASE_MESSAGING_SENDER_ID`
- `VITE_FIREBASE_APP_ID`
- `VITE_FIREBASE_MEASUREMENT_ID` (if using Firebase Analytics)

**Optional Configuration**:
- `TRUSTED_PROXIES` (comma-separated) for proxy/CDN deployments
- `VITE_GA_MEASUREMENT_ID` (future GA4 integration)

**Deployment Process**:
- Slack notifications after workflow completion
- Rollback via Fly's release history
- Environment-specific values separated per Fly app

Implementation references:
- Build/start scripts in `package.json` (`build`, `start`, `validate`)

### Consequences

* Pros: Predictable releases, quick rollback, environment isolation, comprehensive secret management, visibility via Slack
* Cons / risks: Requires branch hygiene, secret rotation discipline, per-environment configuration maintenance
* Supersedes: —
* Superseded by: —

### Compliance / Verification

Secrets audit per environment. Deployment smoke tests verify environment-specific configuration. Rollback procedures tested and documented.

## ADR-0011 — Security Headers and CSP Baseline

<a id="adr-0011"></a>
**Date**: 2025-09-03
**Status**: Implemented
**Owner**: André Roussakoff

### Context

We need a default set of security headers (HSTS, X-Frame-Options, CSP) appropriate for an SSR React Router app.

### Alternatives

- No CSP (higher XSS risk)
- Overly strict CSP (breaks features)
- Ad-hoc headers per route (inconsistent)

### Decision

Adopt a baseline header set (HSTS, frame options, referrer policy, permissions policy) and define a CSP pattern (script-src 'self' plus hashed inline where needed, connect-src for APIs, img-src data: as needed). Exact directives to be finalized after asset inventory.

#### Current Implementation (Interim)

- Implemented minimal CSP and security headers in SSR response construction (`app/entry.server.tsx`).
- Allows `'unsafe-inline'` in `script-src` temporarily to support the small inline SSR snippet in `app/root.tsx`.
- Dev mode adds allowances for Vite HMR (`unsafe-eval`, localhost HTTP/WS). Production enables HSTS.

#### Nonce Migration Plan (Tightening CSP)

1) Generate a per-request nonce in `app/entry.server.tsx` and make it available to rendering (via context/props).
2) Attach the nonce to all inline/script tags:
   - Add `nonce` to the inline SSR script in `app/root.tsx`.
   - Pass the same `nonce` to `<Scripts />` so framework-generated script tags include it (or configure equivalent if required).
3) Update CSP `script-src` to replace `'unsafe-inline'` with `'nonce-<value>'` (keep `'self'`; keep dev HMR allowances in development).
4) Verify no other inline scripts/styles remain; move any remaining inline code to external files.
5) Run with `Content-Security-Policy-Report-Only` first to catch violations; switch to enforcing once clean.

### Consequences

* Pros: Defense-in-depth, consistent security posture
* Cons / risks: Initial tuning needed to avoid breakage
* Supersedes: —
* Superseded by: —

## ADR-0012 — Analytics and Privacy (GA4 Scope)

<a id="adr-0012"></a>
**Date**: 2025-09-03
**Status**: Accepted
**Owner**: André Roussakoff

### Context

We plan to use GA4 for analytics with privacy considerations (anonymization, consent, retention).

### Alternatives

- No analytics (reduced insight)
- Self-hosted analytics (higher maintenance)

### Decision

Define GA4 scope: basic page/navigation events, anonymize IP where applicable, document consent/opt-out, and retention defaults. Avoid PII and ensure configuration is documented.

### Consequences

* Pros: Insight into usage with defined privacy boundaries
* Cons / risks: Compliance obligations and configuration diligence
* Supersedes: —
* Superseded by: —

## ADR-0013 — Testing Strategy and Comprehensive Coverage

<a id="adr-0013"></a>
**Date**: 2025-09-05
**Status**: Accepted
**Owner**: André Roussakoff

### Context

We need a comprehensive testing strategy covering unit, integration, and E2E testing with robust coverage requirements and quality gates.

### Alternatives

- Jest + React Testing Library only (limited E2E coverage)
- Cypress for E2E (heavier, less modern than Playwright)
- Manual testing only (error-prone, slow feedback)
- No coverage requirements (inconsistent quality)

### Decision

Implement comprehensive testing architecture with:

**Testing Frameworks**:
- Vitest for unit/component tests with React Testing Library
- Playwright for E2E tests with role-based test organization
- Coverage thresholds: 70% across all metrics (lines, functions, branches, statements)

**Test Organization**:
- Unit tests: `*.test.ts/tsx` files colocated with components
- E2E tests: `playwright/tests/*.spec.ts` with clear separation
- Role-based E2E projects for testing RBAC scenarios

**Quality Assurance**:
- Automated test execution in CI/CD pipeline
- Coverage reporting and enforcement
- Performance regression testing
- Cross-browser compatibility testing

**Testing Standards**:
- Accessibility testing in critical flows
- Mobile-first responsive testing
- Authentication and role-based access testing
- Error boundary and fallback state testing

### Consequences

* Pros: High confidence in deployments, comprehensive coverage, automated quality gates, consistent testing standards
* Cons / risks: Test maintenance overhead, longer CI runs, initial setup complexity
* Supersedes: —
* Superseded by: —

### Compliance / Verification

CI enforces coverage thresholds. E2E tests run on built artifacts. Cross-browser testing verified. Test-driven development practices documented.

## ADR-0014 — Mobile-First Responsive Design Strategy

<a id="adr-0014"></a>
**Date**: 2025-09-05
**Status**: Accepted
**Owner**: André Roussakoff

### Context

Tournament management requires excellent mobile UX for referees on the field, managers during events, and public users following tournaments. We need a clear mobile-first strategy with desktop enhancement.

### Alternatives

- Desktop-first with mobile adaptations (poor mobile UX)
- Separate mobile app (development overhead)
- Responsive without mobile priority (inconsistent experience)
- Fixed layouts (poor accessibility)

### Decision

Implement mobile-first responsive design with:

**Breakpoint Strategy**:
- Default styles: mobile-first for phones (320px-767px, unprefixed base classes)
- Tablet/Desktop enhancements: Use `md:` (768px+) when tablets should share desktop layout, or `lg:` (1024px+) for desktop-only styles
- **Guideline**: Prefer `md:` over `sm:` to group tablets with desktop unless explicit phone/tablet/desktop differentiation is needed
- Touch targets: minimum 44px for interactive elements
- Safe area handling for notched devices

**Layout Principles**:
- Bottom navigation on mobile for primary sections
- Swipe gestures for secondary actions (delete, edit)
- Thumb-friendly interaction zones
- Vertical scrolling priority over horizontal

**Typography & Spacing**:
- System-UI for Latin text with readable mobile scales
- Amiri for Arabic with visual balance utilities
- Responsive spacing scales with consistent rhythm
- Adequate line height for mobile reading

**Performance Considerations**:
- Mobile-first asset loading
- Responsive images with appropriate densities
- Touch-optimized interaction delays
- Battery-conscious animations and transitions

### Consequences

* Pros: Excellent mobile UX, progressive enhancement, accessibility compliance, unified codebase
* Cons / risks: Desktop layouts require more consideration, larger CSS bundle, mobile testing complexity
* Supersedes: —
* Superseded by: —

### Compliance / Verification

Lighthouse mobile performance ≥90 on critical routes. Touch target audit in accessibility testing. Mobile-first development workflow documented.

## ADR-0015 — Error Handling and Boundaries Architecture

<a id="adr-0015"></a>
**Date**: 2025-09-05
**Status**: Accepted
**Owner**: André Roussakoff

### Context

Tournament management applications require robust error handling for live events where failures could impact ongoing competitions. We need layered error boundaries with appropriate fallback UIs.

### Alternatives

- Global error boundary only (poor UX granularity)
- Component-level try/catch everywhere (boilerplate, inconsistent)
- No error boundaries (poor user experience)
- Client-only error handling (loses SSR errors)

### Decision

Implement layered error boundary architecture:

**Error Boundary Layers**:
- Global error boundary: catches all unhandled errors with full-page fallback
- Auth-specific error boundary: handles authentication failures with retry/sign-out options
- Route-level boundaries: feature-specific error handling with context-appropriate fallbacks
- Component boundaries: for complex components with their own error states

**Error Handling Strategy**:
- SSR-compatible error boundaries that work with React Router
- Graceful degradation with actionable error messages
- Error logging with sanitized public error messages
- Recovery actions where appropriate (retry, refresh, navigate)

**Error Types & Responses**:
- Network errors: retry mechanisms with exponential backoff
- Authentication errors: redirect to sign-in with return path
- Authorization errors: clear permission messaging with contact info
- Data validation errors: inline field-level feedback
- Server errors: friendly messaging with support contact

**Monitoring & Recovery**:
- Error boundary render counts tracked for monitoring
- Automatic error reporting with privacy-safe details
- Clear escalation paths for critical tournament errors
- Admin notifications for system-level failures

### Consequences

* Pros: Resilient user experience, context-appropriate error handling, better debugging, graceful degradation
* Cons / risks: Error boundary maintenance, potential over-engineering, logging overhead
* Supersedes: —
* Superseded by: —

### Compliance / Verification

Error boundary coverage tested with deliberate error injection. SSR error handling verified. Error message clarity and actionability reviewed.

Implementation references:
- Global/auth error boundaries in `app/components/*ErrorBoundary*.tsx`
- SSR header application in `app/entry.server.tsx`

## ADR-0016 — Performance Architecture: Bundle Management and Code Splitting

<a id="adr-0016"></a>
**Date**: 2025-09-05
**Status**: Accepted
**Owner**: André Roussakoff

### Context

Tournament applications need fast loading for mobile users with potentially limited connectivity, while maintaining rich functionality for desktop admin users.

### Alternatives

- Single large bundle (slow initial load, good caching)
- Aggressive micro-splitting (many requests, complexity)
- Route-level splitting only (suboptimal granularity)
- No optimization (poor mobile performance)

### Decision

Implement strategic performance architecture:

**Bundle Strategy**:
- Route-level code splitting for major sections (public, auth, admin)
- Lazy loading for heavy components (charts, rich editors, complex forms)
- Shared chunk optimization for common dependencies
- Critical CSS inlined, non-critical CSS lazy-loaded

**Asset Optimization**:
- Image optimization with responsive sizes and WebP
- Icon system with SVG sprites and currentColor inheritance
- Font loading strategy with fallbacks and font-display: swap
- Service worker caching for static assets

**Loading Strategies**:
- Route prefetching based on user context (intent, render, viewport)
- Component lazy loading with appropriate loading states
- Progressive hydration for heavy interactive components
- Background asset preloading for likely next actions

**Performance Budgets**:
- Initial bundle < 150KB gzipped
- Route chunks < 50KB gzipped
- TTI < 2s on median mobile (cache warmed)
- LCP < 2.5s on slow 3G

**Monitoring**:
- Real User Monitoring for Core Web Vitals
- Bundle size tracking in CI
- Performance regression detection
- Mobile-specific performance metrics

### Consequences

* Pros: Fast mobile loading, efficient caching, scalable architecture, performance visibility
* Cons / risks: Build complexity, lazy loading UX considerations, cache invalidation complexity
* Supersedes: —
* Superseded by: —

### Compliance / Verification

Lighthouse CI enforces performance budgets. Bundle analyzer reports monitored. Real user performance metrics tracked.

## ADR-0017 — Email Integration via Resend

<a id="adr-0017"></a>
**Date**: 2025-09-05
**Status**: Accepted
**Owner**: André Roussakoff

### Context

Tournament management requires reliable email delivery for team registration confirmations, match reminders, schedule changes, and final results. We need a robust email system with good deliverability.

### Alternatives

- SMTP-only solution (deliverability challenges)
- SendGrid or Mailgun (more complex pricing/setup)
- Built-in Node.js SMTP (reliability issues)
- No email integration (poor user experience)

### Decision

Implement email integration via Resend with:

**Email Provider**:
- Resend as primary provider for modern API and good deliverability
- Domain authentication (SPF/DKIM/DMARC) for trust
- Per-environment sender configuration

**Email Templates & Content**:
- Team registration confirmations with tournament details
- Match reminders with time/location/referee information
- Schedule changes with clear before/after details
- Final results wrap-ups with standings and highlights
- Multi-language template support matching app localization

**Delivery Architecture**:
- Outbox pattern for reliable delivery with retry logic
- Background job processing for email sending
- Exponential backoff retry with failure alerts
- Admin dashboard for email delivery monitoring
- Failed email recovery and manual retry capability

**Email Configuration**:
- Environment-specific `EMAIL_FROM` addresses
- `BASE_URL` configuration for email links
- Rate limiting to prevent spam/abuse
- Unsubscribe handling for notification preferences

**Privacy & Compliance**:
- Opt-in only for non-essential communications
- Clear unsubscribe mechanisms
- GDPR-compliant data handling
- Email content sanitization

### Consequences

* Pros: Reliable delivery, professional presentation, automated communication, multi-language support
* Cons / risks: Email deliverability dependency, template maintenance, compliance overhead
* Supersedes: —
* Superseded by: —

### Compliance / Verification

Email delivery rates monitored. Template rendering tested across clients. Unsubscribe flows verified. DMARC alignment confirmed.

## ADR-0018 — Rate Limiting and Security Middleware

<a id="adr-0018"></a>
**Date**: 2025-09-05
**Status**: Accepted
**Owner**: André Roussakoff

### Context

Tournament management platforms are targets for abuse, especially around authentication and sensitive admin actions. We need comprehensive rate limiting without impacting legitimate users.

### Alternatives

- No rate limiting (vulnerable to abuse)
- Basic IP-only limiting (can block legitimate users)
- Third-party service dependency (cost, latency)
- Overly restrictive limits (poor UX)

### Decision

Implement comprehensive rate limiting middleware:

**Rate Limiting Strategy**:
- Memory-safe in-memory store with automatic cleanup
- Multiple rate limit buckets: auth, admin actions, API, public forms
- Sliding window with burst capacity for legitimate traffic
- IP-based with X-Forwarded-For header validation

**Rate Limit Configuration**:
- Auth endpoints (`/auth/signin`): 5 attempts per minute per IP
- Admin actions: 30 requests per minute per authenticated user
- Public team registration: 3 attempts per hour per IP
- General API: 100 requests per minute per IP/user
- Referee score submission: 10 per minute per token

**Security Features**:
- `X-RateLimit-*` headers for client visibility
- Proper IP detection with trusted proxy handling
- Localhost bypass for development and testing
- Rate limit logging and monitoring
- Gradual backoff responses vs hard blocks

**Abuse Prevention**:
- Suspicious pattern detection (rapid requests, failed auth)
- Temporary blocks with automatic expiry
- Admin tools for manual IP blocking/unblocking
- Integration with error logging for attack pattern analysis

**Development & Testing**:
- Rate limits disabled or relaxed in test environments
- Development bypass mechanisms
- Load testing exemption handling

### Consequences

* Pros: Protection against abuse, fair resource usage, attack visibility, configurable per use case
* Cons / risks: Legitimate user blocking, configuration complexity, memory usage for tracking
* Supersedes: —
* Superseded by: —

### Compliance / Verification

Load testing verifies rate limit behavior. Legitimate usage patterns tested. Rate limit bypass mechanisms documented and tested.

## ADR-0019 — Data Model and Migration Strategy

<a id="adr-0019"></a>
**Date**: 2025-09-05
**Status**: Accepted
**Owner**: André Roussakoff

### Context

Tournament management requires a robust data model supporting teams, tournaments, matches, groups, and standings with a clear migration strategy for schema evolution.

### Alternatives

- Schema-less database (lacks data integrity)
- Manual SQL migrations (error-prone)
- ORM with auto-migrations (dangerous in production)
- Separate migration tooling (complexity)

### Decision

Implement Prisma-based data model with controlled migrations:

**Core Data Models**:
- `User`: authentication, roles (ADMIN, MANAGER, REFEREE, PUBLIC)
- `Team`: registration, club information, contact details
- `Tournament`: configuration, categories, divisions, rules
- `Match`: scheduling, scores, referee assignments, status
- `GroupSet`/`Group`/`GroupSlot`: group phase organization
- `MatchScore`: detailed scoring with validation

**Extended Models** (planned):
- `RefereePreAuthToken`: scoped access tokens for referees
- `TeamLeader`: non-authenticated contact for public registration
- `NotificationSubscription`: user alert preferences
- `AuditLog`: system action tracking

**Migration Strategy**:
- Development: `prisma migrate dev` with descriptive names
- Production: explicit `prisma migrate deploy` in CI/CD
- Schema changes minimized per iteration with documentation
- Rollback strategy via migration history and data backups
- Seed data management with `prisma/seed.ts`

**Data Integrity**:
- Foreign key constraints with appropriate cascade rules
- Enum types for status fields and categories
- Unique constraints for business logic (team names per tournament)
- Validation at database and application levels
- Soft deletes for audit trail preservation

**Performance Considerations**:
- Strategic indexes for query patterns
- Connection pooling with appropriate limits
- Query optimization monitoring
- Database size monitoring and archival strategy

### Consequences

* Pros: Strong data integrity, controlled schema evolution, comprehensive audit trail, development productivity
* Cons / risks: Migration complexity, schema lock-in, potential downtime during migrations
* Supersedes: —
* Superseded by: —

### Compliance / Verification

Migration testing in staging environment. Data model validation via integration tests. Performance benchmarking for query patterns.

## ADR-0020 — Offline Capabilities and Background Sync

<a id="adr-0020"></a>
**Date**: 2025-09-05
**Status**: Accepted
**Owner**: André Roussakoff

### Context

Referees need to submit scores reliably even with poor connectivity at tournament venues. We need offline-capable score submission with conflict resolution.

### Alternatives

- Online-only (fails in poor connectivity)
- Full offline-first app (complexity, sync challenges)
- Local storage only (data loss risk)
- Manual sync (poor UX)

### Decision

Implement targeted offline capabilities for critical workflows:

**Offline Scoring System**:
- IndexedDB for persistent score storage when offline
- Background sync queue with automatic retry logic
- Visible pending state indicators for users
- Exponential backoff with jitter for sync attempts
- Conflict resolution UI when server state changes

**Sync Strategy**:
- Service Worker Background Sync API where supported
- Polling fallback for unsupported browsers/contexts
- Last-write-wins with user override for conflicts
- Optimistic updates with rollback on conflict
- Batch sync for efficiency when connectivity returns

**Data Management**:
- Critical data cached in IndexedDB (match assignments, basic info)
- Non-critical data gracefully degraded when offline
- Cache invalidation strategy aligned with server updates
- Storage quota management with cleanup policies
- Secure token storage for offline auth verification

**User Experience**:
- Clear online/offline status indicators
- Offline capability badges for supported features
- Queue status with pending action counts
- Manual sync trigger for user control
- Graceful error handling with actionable messages

**Conflict Resolution**:
- Server-wins vs client-wins options for users
- Detailed diff display for conflicting changes
- Merge assistance for compatible changes
- Escalation to admin for complex conflicts
- Audit trail for conflict resolution decisions

### Consequences

* Pros: Reliable score submission, works in poor connectivity, professional mobile experience, data integrity preserved
* Cons / risks: Complexity in sync logic, storage management overhead, conflict resolution UX challenges
* Supersedes: —
* Superseded by: —

### Compliance / Verification

Offline scenario testing with network simulation. Conflict resolution workflows tested. Storage quota and cleanup verified. Sync performance benchmarked.

## ADR-0021 — Live Updates Transport Architecture

<a id="adr-0021"></a>
**Date**: 2025-09-05
**Status**: Accepted
**Owner**: André Roussakoff

### Context

Tournament management requires real-time updates for live scores, standings changes, and schedule updates to keep all stakeholders informed during active competitions.

### Alternatives

- Polling only (higher bandwidth, delay)
- WebSocket only (complexity, fallback needed)
- Server-Sent Events only (uni-directional)
- No real-time updates (poor live tournament experience)

### Decision

Implement progressive live updates transport:

**Transport Strategy**:
- WebSocket primary for bi-directional, low-latency updates
- Server-Sent Events (SSE) fallback for simpler uni-directional streaming
- HTTP polling as final fallback with intelligent intervals
- Connection health monitoring with automatic failover

**Event Architecture**:
- Event-driven updates for scores, standings, schedules
- Scoped subscriptions (tournament, team, match level)
- Event batching and coalescing for high-frequency updates
- Back-pressure handling with queue management

**Delivery Scopes**:
- Public dashboard: tournament-wide score/schedule updates
- Team followers: team-specific match and result notifications
- Staff interfaces: role-appropriate operational updates
- Referee dashboard: assignment and match status updates

**Performance & Scalability**:
- Connection pooling and load balancing
- Event compression for large payload optimization
- Selective updates (deltas vs full state)
- Rate limiting on subscription changes
- Graceful degradation under load

**Reliability Features**:
- Automatic reconnection with exponential backoff
- Message ordering and deduplication
- Offline queue integration with sync reconciliation
- Connection state management and user feedback
- Fallback to polling during transport failures

### Consequences

* Pros: Engaging live experience, efficient bandwidth usage, robust failover, scalable architecture
* Cons / risks: Infrastructure complexity, connection management overhead, testing complexity across transports
* Supersedes: —
* Superseded by: —

### Compliance / Verification

Load testing across transport methods. Connection recovery scenarios tested. Event delivery reliability verified. Performance benchmarking under various network conditions.

## ADR-0022 — RBAC Middleware and Permission Utilities

<a id="adr-0022"></a>
**Date**: 2025-09-07
**Status**: Accepted
**Owner**: André Roussakoff

### Context

The application enforces a permission matrix across roles (PUBLIC, REFEREE, MANAGER, ADMIN). We need consistent middleware utilities that protect loaders/actions, support self-access where appropriate, and integrate with rate limiting.

### Alternatives

- Route-local checks in each loader/action (repetition, inconsistency)
- Client-only checks (insufficient for SSR security)

### Decision

Adopt centralized RBAC utilities:

- `requireUserWithPermission(request, permission, options)` for permission checks with optional self-access (`allowSelfAccess`, `userIdParam`, and route `params`).
- `requireAdminUser(request)` for admin panel gating (ADMIN/MANAGER/REFEREE access to panel; navigation filtered elsewhere).
- Role-based rate limiting helper `checkRoleBasedRateLimit(request, action)` to apply stricter limits for sensitive operations.

### Implementation References

- Middleware: `app/utils/rbacMiddleware.server.ts`
- Permissions and role helpers: `app/utils/rbac`
- Session utilities: `app/utils/session.server.ts`
- Rate limiting: `app/utils/rateLimit.server.ts`, `app/utils/adminMiddleware.server.ts`

### Consequences

* Pros: Consistency, fewer security footguns, testable contracts, SSR alignment
* Cons / risks: Requires team familiarity with utilities, central updates affect many routes

### Compliance / Verification

- Unit tests for permission paths and self-access conditions
- Route tests for unauthorized/forbidden flows
- Playwright projects for role-based access to admin panel

## ADR-0023 — Environment Variable Management Strategy

<a id="adr-0023"></a>
**Date**: 2025-09-21
**Status**: Accepted
**Owner**: André Roussakoff

### Context

Managing environment variables across multiple deployment environments (CI, staging, production) while maintaining security and avoiding Firebase authentication conflicts in testing required a comprehensive strategy. The challenge was to enable reliable E2E testing without exposing production credentials or creating unnecessary dependencies on external services.

### Alternatives

- **Single Firebase project for all environments**: Security risk, production data exposed to testing
- **Manual environment variable management**: Error-prone, inconsistent across environments
- **Real Firebase authentication in CI**: Slow, unreliable, unnecessary network dependencies
- **Environment separation with automated setup**: Secure, reliable, maintainable

### Decision

Implement comprehensive environment variable management with Firebase project separation:

**Environment Architecture**:
- **CI (GitHub Actions)**: Uses dummy Firebase values for E2E testing, no real Firebase connection
- **Staging (dev branch)**: Uses `tournado-dev` Firebase project for development and testing
- **Production (main branch)**: Uses `tournado-prod` Firebase project for live application

**Automated Setup**:
- `setup-github-secrets.sh`: Configures CI environment with dummy values
- `setup-flyio-secrets.sh`: Configures Fly.io environments with real credentials
- Environment-specific Firebase service accounts with minimal required permissions

**Security Principles**:
- Never share secrets between environments
- Use environment-specific Firebase projects
- Rotate secrets regularly, especially for production
- Use minimum required permissions for service accounts

### Consequences

- **Pros**: Complete environment isolation, automated setup, secure credential management, reliable CI testing
- **Cons / risks**: Additional Firebase project costs, complexity of managing multiple environments
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

- Environment variables documented in comprehensive reference guide
- Setup scripts tested and validated across all environments
- Firebase projects properly isolated with appropriate access controls
- E2E tests run reliably in CI without Firebase dependencies

## ADR-0024 — E2E Testing Firebase Bypass Strategy

<a id="adr-0024"></a>
**Date**: 2025-09-21
**Status**: Accepted
**Owner**: André Roussakoff

### Context

E2E testing with Firebase authentication introduced reliability issues, slow test execution, and unnecessary dependencies on external services. The principle "Test your code, not third-party services" guided the decision to bypass Firebase authentication entirely in favor of session cookie-based testing.

### Alternatives

- **Real Firebase authentication in E2E tests**: Slow, unreliable, tests third-party service functionality
- **Mocked Firebase authentication**: Complex mocking, still tests Firebase integration rather than application logic
- **Session cookie authentication bypass**: Fast, reliable, focuses on application logic
- **Hybrid approach**: Complexity without clear benefits

### Decision

Implement E2E testing strategy that bypasses Firebase authentication entirely:

**Authentication Bypass Mechanism**:
- Create session cookies directly in test setup
- Use separate test database (`prisma/data-test.db`) for complete isolation
- Pre-authenticated test contexts (admin, user, public) for different test scenarios
- Dummy Firebase configuration values that never connect to real services

**Test Architecture**:
- **No Authentication** (`no-auth` project): Test authentication flows and public access
- **User Authentication** (`user-authenticated` project): Test user-level features with pre-authenticated context
- **Admin Authentication** (`admin-authenticated` project): Test admin features with pre-authenticated context

**What IS tested**: Application logic, routing, UI interactions, form validation, authorization (RBAC), database operations, session management

**What is NOT tested**: Firebase sign-in/sign-up/sign-out flows, Google OAuth integration, Firebase security rules, Firebase token validation

### Consequences

- **Pros**: Fast test execution, reliable tests, no external dependencies, environment isolation, easier debugging
- **Cons / risks**: Firebase integration must be tested manually, authentication complexity not fully exercised
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

- E2E tests run reliably in CI without Firebase service dependencies
- Authentication contexts work correctly for role-based testing
- Manual testing procedures documented for Firebase integration validation
- Test database properly isolated from development and production data

## ADR-0025 — Competition Section Structure and Group Management

<a id="adr-0025"></a>
**Date**: 2025-10-08
**Status**: Accepted
**Owner**: André Roussakoff

### Context

Tournament management requires organized workflows for different phases of competition management. We need a clear structure for managing groups, matches, and standings while providing intuitive access to team allocation and match scheduling features.

### Alternatives

- **Flat navigation structure**: All features at same level (poor organization, confusing navigation)
- **Feature-specific pages without grouping**: Scattered functionality, no clear workflow progression
- **Groups under Teams section**: Logically incorrect, groups are competition artifacts not team properties
- **Competition section with Groups → Matches → Standings workflow**: Clear progression, intuitive organization

### Decision

Implement Competition section as central hub for tournament operations with structured workflow:

**Competition Section Structure**:
- **Location**: `/a7k9m2x5p8w1n4q6r3y8b5t1/competition`
- **Phase progression**: Groups (setup) → Matches (play) → Standings (results)
- **Navigation**: Admin Panel → Competition Management

**Group Management Workflow** (TASK-0301):
- View group sets for selected tournaments
- Assign teams from reserve to group slots
- Move teams between groups and reserve
- Swap teams between slots
- Clear slots to return teams to reserve
- Transactional operations ensuring data consistency

**Permission Model**:
- `groups:manage` permission required (ADMIN and MANAGER roles)
- RBAC enforcement at route loader/action level
- Self-service team management separate from competition administration

**Database Operations**:
- Atomic transactions for multi-step assignments
- Unique constraints: one team per slot, team appears once per group set
- Cascade handling for team/tournament deletions
- Optimistic locking for concurrent operations

### Implementation References

- Group models: `app/models/group.server.ts`
- Competition routes: `app/routes/a7k9m2x5p8w1n4q6r3y8b5t1/competition/**`
- RBAC middleware: `app/utils/rbacMiddleware.server.ts`
- Database schema: `prisma/schema.prisma` (GroupSet, Group, GroupSlot)

### Consequences

- **Pros**: Clear workflow progression, intuitive navigation, data integrity, role-based access, organized tournament management
- **Cons / risks**: Competition section grows with features, need to maintain consistent navigation UX, transaction complexity
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

- Unit tests verify transactional group assignment operations
- E2E tests confirm RBAC enforcement and workflow completion
- Database constraints prevent invalid team assignments
- UI clearly indicates workflow progression and current phase

**PRD Phase Alignment**: This ADR supports Phase 3 (Groups & Playoffs MVP) implementation.

## ADR-0026 — User Management Workflows and Admin Controls

<a id="adr-0026"></a>
**Date**: 2025-10-08
**Status**: Implemented
**Owner**: André Roussakoff
**Completed**: 2025-11-01

### Context

With Firebase authentication established (Phase 1), we need a comprehensive user management system that allows administrators to control user access and roles. This is a foundational requirement before implementing tournament operations (groups, matches, scoring) since those features depend on proper role assignment and user approval workflows.

### Alternatives

- **No explicit user management**: Rely only on environment-based super admin assignment (insufficient for scale)
- **Automatic role assignment**: All authenticated users get default roles (security risk, no approval workflow)
- **Manager-controlled role assignment**: Violates principle of least privilege (only ADMIN should assign roles)
- **Admin-controlled user management with approval workflows**: Secure, scalable, follows RBAC principles

### Decision

Implement comprehensive admin-controlled user management as Phase 2 of the PRD:

**User Management Features**:
- **User Approval System**: Admin reviews and approves/rejects new user registrations
- **Role Assignment**: Admin assigns ADMIN or MANAGER roles (REFEREE uses pre-auth tokens, not registered accounts)
- **User List**: Searchable, filterable list of all users with role and status indicators
- **User Profiles**: View and edit user profile information
- **Activity Monitoring**: Audit logs for role changes and significant user actions

**Access Control**:
- **Permission**: `users:approve`, `roles:assign` (ADMIN role only)
- **Panel Location**: Admin Panel → User Management section
- **RBAC Enforcement**: Route-level permission checks via `requireUserWithPermission`

**User Lifecycle**:
1. User signs up via Firebase Authentication (Google OAuth or Email/Password)
2. User account created with PUBLIC role by default
3. Admin reviews pending user in User Management panel
4. Admin approves user and optionally assigns MANAGER role
5. User gains access to role-appropriate features
6. Admin can modify roles or revoke access as needed

**Audit Trail**:
- Log all role assignments and changes
- Track approval/rejection decisions with timestamps and admin identifiers
- Maintain user activity history for security and compliance

**Why Before Groups/Matches**:
- Managers need to be properly authorized before they can manage tournaments
- Clear separation between user administration (Phase 2) and tournament operations (Phase 3+)
- Establishes proper RBAC foundation for all subsequent features
- Referee token management (Phase 4) depends on properly authorized managers

### Implementation References

- **Implementation Task**: TASK-0201 (User Management Admin Workflows) - **Completed**: 2025-11-01
- User models: `app/models/user.server.ts` (implemented with management functions)
- User audit log model: `app/models/userAuditLog.server.ts` (implemented)
- User management routes: `app/routes/a7k9m2x5p8w1n4q6r3y8b5t1/users/**` (implemented)
- User management components: `app/features/users/components/**` (implemented)
- Firebase integration: `app/features/firebase/server.ts` (user disable/enable, token revocation)
- RBAC middleware: `app/utils/rbacMiddleware.server.ts`
- Permissions: `app/utils/rbac/permissions.ts`
- Database schema: `prisma/schema.prisma` (User.active, User.displayName, UserAuditLog model)
- Unit tests: `app/models/__tests__/user.server.test.ts` (58 comprehensive tests)
- E2E tests: `playwright/tests/users.spec.ts` (14 scenarios)
- Page Object Model: `playwright/pages/AdminUsersPage.ts`

### Consequences

- **Pros**: Controlled user access, proper RBAC foundation, security compliance, scalable user management, audit trail for accountability
- **Cons / risks**: Additional admin overhead for user approval, need for clear approval criteria/documentation, potential user registration friction
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

✅ **All verification criteria met:**

- ✅ 58 unit tests verify permission enforcement for all user management operations
- ✅ 14 E2E test scenarios confirm only ADMIN can access user management features
- ✅ Audit logs properly record all role changes, deactivations, and reactivations
- ✅ Self-edit prevention: users cannot change their own role or deactivate themselves
- ✅ Database constraints ensure valid role transitions
- ✅ Firebase integration: deactivated users cannot sign in, active sessions invalidated
- ✅ Multi-layer deactivation enforcement: Firebase account disabled, authentication callbacks reject inactive users, InfoBanner displays deactivation notice, database as source of truth
- ✅ Server-side i18n: localized error messages for role change prevention, deactivation errors, and validation failures via `getServerT`
- ✅ ComboField accessibility: keyboard navigation, screen reader support, and ARIA attributes for role assignment dropdown
- ✅ Accessibility verification: proper form structure, ARIA attributes, keyboard navigation across all user management interfaces

**PRD Phase Alignment**: This ADR defines Phase 2 (User Management) implementation requirements.

**Implementation Status**: **Completed**: 2025-11-01 - See `.cursor/tasks/TASK-0201-user-management-admin-workflows.mdc` for implementation details.

## ADR-0027 — Semantic Heading Hierarchy with AppBar h1

<a id="adr-0027"></a>
**Date**: 2025-10-24
**Status**: Accepted
**Owner**: André Roussakoff

### Context

Modern single-page applications with persistent navigation chrome (AppBar/Header) face a decision about semantic heading hierarchy. The question is whether the app title shown in the persistent AppBar should be an `h1` or secondary heading (`h2`), and how this affects the document outline and accessibility.

### Alternatives

- **AppBar uses h2**: Requires every page to provide its own `h1`, leading to redundant headings that duplicate the AppBar title with no value to users
- **AppBar uses h1**: Follows SPA pattern where persistent chrome provides the primary heading, page content uses `h2`/`h3` for structure
- **Mixed approach**: Some pages use `h1`, others don't (inconsistent, confusing)
- **No semantic headings**: Use divs with heading styles (poor accessibility)

### Decision

Implement semantic heading hierarchy where AppBar's `pageTitle` serves as the primary `h1` heading:

**Heading Architecture**:
- **AppBar h1**: Primary page heading set via `handle.pageTitle` in each route file
- **Page content**: Uses `h2` for major sections, `h3` for subsections
- **Dynamic per route**: The `h1` content changes for each route, making it semantically meaningful
- **Single h1 per page**: Each route has exactly one `h1`, maintaining proper document structure

**Route Pattern**:
```tsx
// Route file example
export const handle: RouteMetadata = {
  pageTitle: 'Teams'  // → Becomes h1 in AppBar
}

// Page content structure
<div>
  <h2>Active Teams</h2>      // Major section
  <h3>Division A</h3>         // Subsection
  <h2>Archived Teams</h2>     // Major section
</div>
```

**Why This Works**:
- Follows modern SPA pattern used by Gmail, GitHub, and many professional web apps
- Screen readers get clear, consistent primary heading that updates on navigation
- Eliminates redundant headings that would just duplicate the AppBar title
- Maintains proper semantic hierarchy for accessibility
- Reduces maintenance overhead (no need to add h1 to every page)

### Implementation References

- AppBar component: `app/components/AppBar.tsx` (h1 with explanatory comment)
- Route metadata: `app/lib/lib.types.ts` (RouteMetadata type with pageTitle)
- Architecture documentation: `CLAUDE.md` (Component Architecture section)

### Consequences

- **Pros**: Proper semantic structure, consistent accessibility, less redundancy, follows modern SPA patterns, clear document outline
- **Cons / risks**: Differs from traditional multi-page website patterns, requires team understanding of SPA heading hierarchy
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

- Accessibility audit confirms single h1 per route with proper hierarchy
- Screen reader testing validates heading navigation experience
- Documentation clearly explains heading pattern for contributors
- All routes define `pageTitle` in their handle export for consistency
