name: CI

on:
  push:
    branches:
      - "**"
  pull_request:
    branches:
      - "**"

defaults:
  run:
    shell: bash

jobs:
  check_changes:
    name: 🔍 Check Changes
    runs-on: ubuntu-latest
    outputs:
      code_changed: ${{ steps.check_changes.outputs.code_changed }}
    steps:
      - name: ⬇️ Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: 🔍 Check for code changes
        id: check_changes
        run: |
          # For PRs, compare against the target branch
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.event.pull_request.head.sha }}"
            git fetch origin $BASE_SHA
            changed_files=$(git diff --name-only $BASE_SHA..$HEAD_SHA)
          else
            # For pushes, compare with previous commit
            changed_files=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "all_files_changed")
          fi

          echo "Changed files:"
          echo "$changed_files"

          # Check if any files outside .github/workflows changed
          if echo "$changed_files" | grep -v "^\.github/workflows/" | grep -q .; then
            echo "code_changed=true" >> $GITHUB_OUTPUT
            echo "📝 Code changes detected - running full CI"
          else
            echo "code_changed=false" >> $GITHUB_OUTPUT
            echo "ℹ️ Only workflow changes detected - still running full CI"
          fi

  lint:
    name: ⬣ ESLint
    runs-on: ubuntu-latest
    needs: check_changes
    permissions:
      contents: read
    steps:
      - name: ⬇️ Checkout repo
        uses: actions/checkout@v4

      - name: ⎔ Setup node
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: ⎔ Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: 10
          run_install: false

      - name: Get pnpm store directory
        id: pnpm-cache
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: 📥 Install deps
        run: pnpm install --no-frozen-lockfile

      - name: 🛠 Generate Prisma Client
        run: pnpm exec prisma generate

      - name: 🔬 Lint
        run: pnpm lint

  typecheck:
    name: ʦ TypeScript
    runs-on: ubuntu-latest
    needs: check_changes
    permissions:
      contents: read
    steps:
      - name: ⬇️ Checkout repo
        uses: actions/checkout@v4

      - name: ⎔ Setup node
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: ⎔ Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: 10
          run_install: false

      - name: Get pnpm store directory
        id: pnpm-cache
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: 📥 Install deps
        run: pnpm install --no-frozen-lockfile

      - name: 🛠 Generate Prisma Client
        run: pnpm exec prisma generate

      - name: 🔎 Type check
        run: pnpm typecheck

  vitest:
    name: ⚡ Vitest
    runs-on: ubuntu-latest
    needs: check_changes
    permissions:
      contents: read
    outputs:
      coverage_lines: ${{ steps.coverage_summary.outputs.lines }}
      coverage_statements: ${{ steps.coverage_summary.outputs.statements }}
      coverage_functions: ${{ steps.coverage_summary.outputs.functions }}
      coverage_branches: ${{ steps.coverage_summary.outputs.branches }}
    steps:
      - name: ⬇️ Checkout repo
        uses: actions/checkout@v4

      - name: ⎔ Setup node
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: ⎔ Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: 10
          run_install: false

      - name: Get pnpm store directory
        id: pnpm-cache
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: 📥 Install deps
        run: pnpm install --no-frozen-lockfile

      - name: 🛠 Generate Prisma Client
        run: pnpm exec prisma generate

      - name: 🛠 Setup Test Database
        run: pnpm exec prisma migrate reset --force
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          SUPER_ADMIN_PASSWORD: ${{ secrets.SUPER_ADMIN_PASSWORD }}

      - name: ⚡ Run vitest
        run: pnpm test:coverage
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          SESSION_SECRET: ${{ secrets.SESSION_SECRET }}
          SUPER_ADMIN_PASSWORD: ${{ secrets.SUPER_ADMIN_PASSWORD }}
          FIREBASE_ADMIN_PROJECT_ID: ${{ secrets.FIREBASE_ADMIN_PROJECT_ID }}
          FIREBASE_ADMIN_CLIENT_EMAIL: ${{ secrets.FIREBASE_ADMIN_CLIENT_EMAIL }}
          FIREBASE_ADMIN_PRIVATE_KEY: ${{ secrets.FIREBASE_ADMIN_PRIVATE_KEY }}

      - name: 🧮 Collect coverage summary
        id: coverage_summary
        run: |
          summary_file=coverage/coverage-summary.json

          if [ ! -f "$summary_file" ]; then
            echo "Coverage summary file not found at $summary_file"
            exit 1
          fi

          lines=$(jq '.total.lines.pct' "$summary_file")
          statements=$(jq '.total.statements.pct' "$summary_file")
          functions=$(jq '.total.functions.pct' "$summary_file")
          branches=$(jq '.total.branches.pct' "$summary_file")

          lines_fmt=$(LC_ALL=C printf '%.2f' "$lines")
          statements_fmt=$(LC_ALL=C printf '%.2f' "$statements")
          functions_fmt=$(LC_ALL=C printf '%.2f' "$functions")
          branches_fmt=$(LC_ALL=C printf '%.2f' "$branches")

          {
            echo "### Vitest Coverage" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "| Metric | Percentage |" >> "$GITHUB_STEP_SUMMARY"
            echo "| --- | --- |" >> "$GITHUB_STEP_SUMMARY"
            printf '| Lines | %s%% |\n' "$lines_fmt" >> "$GITHUB_STEP_SUMMARY"
            printf '| Statements | %s%% |\n' "$statements_fmt" >> "$GITHUB_STEP_SUMMARY"
            printf '| Functions | %s%% |\n' "$functions_fmt" >> "$GITHUB_STEP_SUMMARY"
            printf '| Branches | %s%% |\n' "$branches_fmt" >> "$GITHUB_STEP_SUMMARY"
          }

          echo "lines=$lines_fmt" >> "$GITHUB_OUTPUT"
          echo "statements=$statements_fmt" >> "$GITHUB_OUTPUT"
          echo "functions=$functions_fmt" >> "$GITHUB_OUTPUT"
          echo "branches=$branches_fmt" >> "$GITHUB_OUTPUT"

  workflow_only_success:
    name: ✅ Workflow Changes Only
    runs-on: ubuntu-latest
    needs: check_changes
    if: needs.check_changes.outputs.code_changed == 'false'
    steps:
      - name: ✅ Workflow validation passed
        run: |
          echo "🚀 Only workflow files changed - notifying deployment pipeline"

  notify_slack:
    name: Notify Slack
    runs-on: ubuntu-latest
    needs:
      - check_changes
      - lint
      - typecheck
      - vitest
      - workflow_only_success
    if: always()
    steps:
      - name: Sanitize values
        id: sanitize
        run: |
          # Sanitize commit message by removing newlines and quotes
          SANITIZED_COMMIT_MESSAGE=$(echo "${{ github.event.head_commit.message }}" | tr '\n\r' ' ' | sed 's/"/\\"/g')
          echo "sanitized_commit_message=$SANITIZED_COMMIT_MESSAGE" >> $GITHUB_OUTPUT

          # Sanitize actor name
          SANITIZED_ACTOR=$(echo "${{ github.actor }}" | tr '\n\r' ' ' | sed 's/"/\\"/g')
          echo "sanitized_actor=$SANITIZED_ACTOR" >> $GITHUB_OUTPUT

          # Sanitize branch name
          SANITIZED_BRANCH=$(echo "${{ github.ref_name }}" | tr '\n\r' ' ' | sed 's/"/\\"/g')
          echo "sanitized_branch=$SANITIZED_BRANCH" >> $GITHUB_OUTPUT

      - name: Post a message in a channel
        uses: slackapi/slack-github-action@v2.1.0
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          webhook-type: incoming-webhook
          payload: |
            {
              "text": "${{
                format('GitHub Action build result: {0} on branch {1} by {2}\nCoverage — L:{6}% S:{7}% F:{8}% B:{9}%\nE2E suite runs separately after CI.\n{3}/{4}/commit/{5}',
                  (needs.lint.result == 'success' && needs.typecheck.result == 'success' && needs.vitest.result == 'success') && 'success' || 'failure',
                  steps.sanitize.outputs.sanitized_branch,
                  steps.sanitize.outputs.sanitized_actor,
                  github.server_url,
                  github.repository,
                  github.sha,
                  needs.vitest.outputs.coverage_lines || 'n/a',
                  needs.vitest.outputs.coverage_statements || 'n/a',
                  needs.vitest.outputs.coverage_functions || 'n/a',
                  needs.vitest.outputs.coverage_branches || 'n/a'
                )
              }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "${{
                      format('GitHub Action build result: {0} on branch `{1}`\n*Triggered by:* {2}\n*Change type:* {3}\n*Coverage:* Lines {9}% | Statements {10}% | Functions {11}% | Branches {12}%\n*E2E Tests:* tracked via the `E2E` workflow\n*Commit message:* {4}\n<{5}/{6}/commit/{7}|View Commit> | <{5}/{6}/actions/runs/{8}|View Workflow Run>',
                        (needs.lint.result == 'success' && needs.typecheck.result == 'success' && needs.vitest.result == 'success') && 'success' || 'failure',
                        steps.sanitize.outputs.sanitized_branch,
                        steps.sanitize.outputs.sanitized_actor,
                        needs.check_changes.outputs.code_changed == 'true' && 'Code changes' || 'Workflow changes only',
                        steps.sanitize.outputs.sanitized_commit_message,
                        github.server_url,
                        github.repository,
                        github.sha,
                        github.run_id,
                        needs.vitest.outputs.coverage_lines || 'n/a',
                        needs.vitest.outputs.coverage_statements || 'n/a',
                        needs.vitest.outputs.coverage_functions || 'n/a',
                        needs.vitest.outputs.coverage_branches || 'n/a'
                      )
                    }}"
                  }
                }
              ]
            }
