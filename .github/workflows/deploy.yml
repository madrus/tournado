name: Deploy

run-name: Deploy - ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_branch || github.ref_name }}

on:
  workflow_run:
    workflows: ["CI"]
    types:
      - completed
    branches:
      - dev
  workflow_dispatch:
    inputs:
      workflow_run_id:
        description: "Optional CI workflow_run id to validate before deploying to production"
        required: false

concurrency:
  group: ${{ github.workflow }}-${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_branch || github.ref_name }}
  cancel-in-progress: true # Cancel similar active workflows

permissions:
  contents: read
  deployments: write
  id-token: write

jobs:
  deploy_staging:
    name: Deploy to Staging (dev)
    if: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_branch == 'dev' && github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    env:
      FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
    outputs:
      code_changed: ${{ steps.check_changes.outputs.code_changed }}
      image_exists: ${{ steps.check_image.outputs.image_exists }}
    permissions:
      contents: read
      actions: read
    steps:
      - name: ‚úÖ Check core tests passed
        run: |
          echo "Checking CI workflow results..."
          echo "Workflow conclusion: ${{ github.event.workflow_run.conclusion }}"

          # Get the workflow run details to check individual job results
          curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
               -H "Accept: application/vnd.github.v3+json" \
               "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.event.workflow_run.id }}/jobs" \
               > jobs.json

          # Debug: Show all jobs and their status
          echo "=== All jobs and their status ==="
          cat jobs.json | jq -r '.jobs[] | "\(.name): \(.conclusion)"'
          echo "================================="

          # Check if core jobs passed (lint, typecheck, vitest) - IGNORE E2E
          # DEPLOYMENT POLICY EXCEPTION: E2E tests are intentionally excluded from staging deployment gate
          # Rationale: E2E tests are flaky and time-consuming; staging serves as the E2E validation environment
          # Core quality gates (lint, typecheck, unit tests) still enforced per CI/CD policy
          LINT_STATUS=$(cat jobs.json | jq -r '.jobs[] | select(.name == "‚¨£ ESLint") | .conclusion')
          TYPECHECK_STATUS=$(cat jobs.json | jq -r '.jobs[] | select(.name == " ¶ TypeScript") | .conclusion')
          VITEST_STATUS=$(cat jobs.json | jq -r '.jobs[] | select(.name == "‚ö° Vitest") | .conclusion')
          WORKFLOW_ONLY_STATUS=$(cat jobs.json | jq -r '.jobs[] | select(.name == "‚úÖ Workflow Changes Only") | .conclusion')

          echo "Lint status: $LINT_STATUS"
          echo "TypeCheck status: $TYPECHECK_STATUS"
          echo "Vitest status: $VITEST_STATUS"
          echo "Workflow only status: $WORKFLOW_ONLY_STATUS"
          echo "Note: E2E test results are ignored for deployment decisions (see policy exception above)"

          # If workflow only changes and that job succeeded, allow deployment
          if [[ "$WORKFLOW_ONLY_STATUS" == "success" ]]; then
            echo "‚úÖ Workflow changes only - proceeding with deployment"
            exit 0
          fi

          # Otherwise, require core tests to pass (E2E failures are non-blocking)
          if [[ "$LINT_STATUS" == "success" && "$TYPECHECK_STATUS" == "success" && "$VITEST_STATUS" == "success" ]]; then
            echo "‚úÖ Core tests passed - proceeding with deployment (E2E status: ignored)"
            exit 0
          else
            echo "‚ùå Core tests failed - blocking deployment"
            exit 1
          fi

      - name: ‚¨áÔ∏è Checkout repo
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}
          fetch-depth: 2 # Need 2 commits to compare

      - name: üîç Check for code changes
        id: check_changes
        run: |
          # Get the list of changed files
          git diff --name-only HEAD~1 HEAD > changed_files.txt

          # Check if any files outside .github/workflows changed
          if grep -v "^\.github/workflows/" changed_files.txt | grep -q .; then
            echo "code_changed=true" >> $GITHUB_OUTPUT
            echo "üìù Code changes detected"
            cat changed_files.txt
          else
            echo "code_changed=false" >> $GITHUB_OUTPUT
            echo "üö´ Only workflow changes detected, no code changes"
          fi

      - name: üëÄ Read app name
        uses: SebRollen/toml-action@v1.2.0
        id: app_name
        with:
          file: fly.toml
          field: app

      - name: üéà Setup Fly
        uses: superfly/flyctl-actions/setup-flyctl@v1

      - name: üîç Check if image exists for this commit
        id: check_image
        if: steps.check_changes.outputs.code_changed == 'false'
        run: |
          # Check if an image with this commit SHA already exists
          if flyctl image show --app ${{ steps.app_name.outputs.value }}-staging | grep -q "${{ github.event.workflow_run.head_sha }}"; then
            echo "image_exists=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Image already exists for commit ${{ github.event.workflow_run.head_sha }}"
          else
            echo "image_exists=false" >> $GITHUB_OUTPUT
            echo "‚ùå No image found for commit ${{ github.event.workflow_run.head_sha }}"
          fi

      - name: üö´ Abort when no deployable image is available
        if: steps.check_changes.outputs.code_changed == 'false' && steps.check_image.outputs.image_exists != 'true'
        run: |
          echo "‚ùå No prebuilt image available for commit ${{ github.event.workflow_run.head_sha }}; skipping deploy." >&2
          exit 1

      - name: üöÄ Deploy to Staging (Build & Deploy)
        if: steps.check_changes.outputs.code_changed == 'true'
        run: |
          echo "üî® Building and deploying new code changes..."
          flyctl deploy --remote-only \
            --build-arg COMMIT_SHA=${{ github.event.workflow_run.head_sha }} \
            --app ${{ steps.app_name.outputs.value }}-staging \
            --strategy rolling \
            --max-unavailable 0.33 \
            --wait-timeout 5m \
            --yes

      - name: üöÄ Deploy to Staging (Deploy Only)
        if: steps.check_changes.outputs.code_changed == 'false' && steps.check_image.outputs.image_exists == 'true'
        run: |
          echo "üì¶ Deploying existing image (no code changes)..."
          # Deploy the existing image without rebuilding
          flyctl deploy --image-label ${{ github.event.workflow_run.head_sha }} \
            --app ${{ steps.app_name.outputs.value }}-staging \
            --strategy rolling \
            --max-unavailable 0.33 \
            --wait-timeout 2m \
            --yes

      - name: Debug Slack Webhook URL
        run: |
          if [ -z "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
            echo "SLACK_WEBHOOK_URL secret is not available"
          else
            echo "SLACK_WEBHOOK_URL secret is available (length: ${#SLACK_WEBHOOK_URL})"
          fi
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify Slack of successful deployment to Staging
        if: ${{ success() }}
        uses: slackapi/slack-github-action@v2.1.0
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          webhook-type: incoming-webhook
          payload: |
            {
              "text": "Deployment successful: dev deployed to staging by ${{ github.event.workflow_run.actor.login }}\nApp: ${{ steps.app_name.outputs.value }}-staging\nCommit: ${{ github.event.workflow_run.head_sha }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Deployment successful*: `dev` deployed to staging by `${{ github.event.workflow_run.actor.login }}`\n*App:* `${{ steps.app_name.outputs.value }}-staging`\n*Commit:* <${{ github.server_url }}/${{ github.repository }}/commit/${{ github.event.workflow_run.head_sha }}|${{ github.event.workflow_run.head_sha }}>\n*Workflow:* <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Deployment Run>"
                  }
                }
              ]
            }

      - name: Notify Slack of failed deployment to Staging
        if: ${{ failure() }}
        uses: slackapi/slack-github-action@v2.1.0
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          webhook-type: incoming-webhook
          payload: |
            {
              "text": "Deployment failed: dev deployment to staging failed\nCommit: ${{ github.event.workflow_run.head_sha }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Deployment failed*: `dev` deployment to staging failed\n*Commit:* <${{ github.server_url }}/${{ github.repository }}/commit/${{ github.event.workflow_run.head_sha }}|${{ github.event.workflow_run.head_sha }}>\n*Workflow:* <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Deployment Run>"
                  }
                }
              ]
            }

  deploy_production:
    name: Deploy to Production (main)
    if: ${{ github.event_name == 'workflow_dispatch' && github.ref_name == 'main' }}
    runs-on: ubuntu-latest
    env:
      FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
    outputs:
      code_changed: ${{ steps.check_changes.outputs.code_changed }}
      image_exists: ${{ steps.check_image.outputs.image_exists }}
    permissions:
      contents: read
      actions: read
    steps:
      - name: üîß Prepare deployment context
        id: prepare_deployment
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          MANUAL_WORKFLOW_RUN_ID: ${{ github.event.inputs.workflow_run_id }}
          TARGET_BRANCH: ${{ github.ref_name }}
          TARGET_SHA: ${{ github.sha }}
        run: |
          set -euo pipefail

          # Prefer an explicit workflow_run id supplied via the manual dispatch payload
          if [[ -n "$MANUAL_WORKFLOW_RUN_ID" ]]; then
            RUN_ID="$MANUAL_WORKFLOW_RUN_ID"
            echo "Using workflow_run id provided via manual trigger: $RUN_ID"
          else
            # Fall back to locating the latest completed CI run for the same commit on the target branch
            echo "Looking up latest completed CI run for branch $TARGET_BRANCH"
            curl -H "Authorization: token $GITHUB_TOKEN" \
                 -H "Accept: application/vnd.github.v3+json" \
                 "https://api.github.com/repos/${{ github.repository }}/actions/workflows/ci.yml/runs?branch=$TARGET_BRANCH&status=completed&per_page=20" \
                 > runs.json

            RUN_ID=$(jq -r --arg sha "$TARGET_SHA" '.workflow_runs[] | select(.head_sha == $sha) | .id' runs.json | head -n 1)

            if [[ -z "$RUN_ID" || "$RUN_ID" == "null" ]]; then
              echo "‚ùå Unable to locate a completed CI run for commit $TARGET_SHA on branch $TARGET_BRANCH" >&2
              exit 1
            fi
            echo "‚úÖ Found CI workflow run: $RUN_ID"
          fi

          # Pull commit metadata from the CI run so downstream steps can behave exactly like the auto path
          curl -H "Authorization: token $GITHUB_TOKEN" \
               -H "Accept: application/vnd.github.v3+json" \
               "https://api.github.com/repos/${{ github.repository }}/actions/runs/$RUN_ID" \
               > run.json

          HEAD_SHA=$(jq -r '.head_sha' run.json)
          HEAD_BRANCH=$(jq -r '.head_branch' run.json)
          ACTOR=$(jq -r '.actor.login' run.json)
          CONCLUSION=$(jq -r '.conclusion' run.json)

          if [[ -z "$HEAD_SHA" || "$HEAD_SHA" == "null" ]]; then
            echo "‚ùå Unable to read commit SHA from workflow run $RUN_ID" >&2
            exit 1
          fi

          # Guard against accidentally deploying a run from a different branch than the manual trigger
          if [[ "$HEAD_BRANCH" != "$TARGET_BRANCH" ]]; then
            echo "‚ùå CI workflow run branch ($HEAD_BRANCH) does not match manual trigger branch ($TARGET_BRANCH)" >&2
            exit 1
          fi

          echo "workflow_run_id=$RUN_ID" >> "$GITHUB_OUTPUT"
          echo "head_sha=$HEAD_SHA" >> "$GITHUB_OUTPUT"
          echo "actor=$ACTOR" >> "$GITHUB_OUTPUT"
          echo "workflow_run_conclusion=$CONCLUSION" >> "$GITHUB_OUTPUT"

          rm -f runs.json run.json

      - name: ‚úÖ Check core tests passed
        env:
          WORKFLOW_RUN_ID: ${{ steps.prepare_deployment.outputs.workflow_run_id }}
          WORKFLOW_RUN_CONCLUSION: ${{ steps.prepare_deployment.outputs.workflow_run_conclusion }}
        run: |
          echo "Checking CI workflow results..."
          echo "Workflow conclusion: $WORKFLOW_RUN_CONCLUSION"

          # Get the workflow run details to check individual job results
          curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
               -H "Accept: application/vnd.github.v3+json" \
               "https://api.github.com/repos/${{ github.repository }}/actions/runs/$WORKFLOW_RUN_ID/jobs" \
               > jobs.json

          # Debug: Show all jobs and their status
          echo "=== All jobs and their status ==="
          cat jobs.json | jq -r '.jobs[] | "\(.name): \(.conclusion)"'
          echo "================================="

          # Check if core jobs passed (lint, typecheck, vitest)
          # DEPLOYMENT POLICY EXCEPTION: E2E tests are intentionally excluded from production deployment gate
          # Rationale: E2E tests are flaky and time-consuming; manual verification on staging required before production deploy
          # Core quality gates (lint, typecheck, unit tests) still enforced per CI/CD policy
          LINT_STATUS=$(cat jobs.json | jq -r '.jobs[] | select(.name == "‚¨£ ESLint") | .conclusion')
          TYPECHECK_STATUS=$(cat jobs.json | jq -r '.jobs[] | select(.name == " ¶ TypeScript") | .conclusion')
          VITEST_STATUS=$(cat jobs.json | jq -r '.jobs[] | select(.name == "‚ö° Vitest") | .conclusion')
          WORKFLOW_ONLY_STATUS=$(cat jobs.json | jq -r '.jobs[] | select(.name == "‚úÖ Workflow Changes Only") | .conclusion')

          echo "Lint status: $LINT_STATUS"
          echo "TypeCheck status: $TYPECHECK_STATUS"
          echo "Vitest status: $VITEST_STATUS"
          echo "Workflow only status: $WORKFLOW_ONLY_STATUS"
          echo "Note: E2E test results are not checked for production deployment (see policy exception above)"

          # If workflow only changes and that job succeeded, allow deployment
          if [[ "$WORKFLOW_ONLY_STATUS" == "success" ]]; then
            echo "‚úÖ Workflow changes only - proceeding with deployment"
            exit 0
          fi

          # Otherwise, require core tests to pass
          if [[ "$LINT_STATUS" == "success" && "$TYPECHECK_STATUS" == "success" && "$VITEST_STATUS" == "success" ]]; then
            echo "‚úÖ Core tests passed - proceeding with deployment"
            exit 0
          else
            echo "‚ùå Core tests failed - blocking deployment"
            exit 1
          fi

      - name: ‚¨áÔ∏è Checkout repo
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.prepare_deployment.outputs.head_sha }}
          fetch-depth: 2 # Need 2 commits to compare

      - name: üîç Check for code changes
        id: check_changes
        run: |
          # Get the list of changed files
          git diff --name-only HEAD~1 HEAD > changed_files.txt

          # Check if any files outside .github/workflows changed
          if grep -v "^\.github/workflows/" changed_files.txt | grep -q .; then
            echo "code_changed=true" >> $GITHUB_OUTPUT
            echo "üìù Code changes detected"
            cat changed_files.txt
          else
            echo "code_changed=false" >> $GITHUB_OUTPUT
            echo "üö´ Only workflow changes detected, no code changes"
          fi

      - name: üëÄ Read app name
        uses: SebRollen/toml-action@v1.2.0
        id: app_name
        with:
          file: fly.toml
          field: app

      - name: üéà Setup Fly
        uses: superfly/flyctl-actions/setup-flyctl@v1

      - name: üîç Check if image exists for this commit
        id: check_image
        if: steps.check_changes.outputs.code_changed == 'false'
        run: |
          # Check if an image with this commit SHA already exists
          if flyctl image show --app ${{ steps.app_name.outputs.value }} | grep -q "${{ steps.prepare_deployment.outputs.head_sha }}"; then
            echo "image_exists=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Image already exists for commit ${{ steps.prepare_deployment.outputs.head_sha }}"
          else
            echo "image_exists=false" >> $GITHUB_OUTPUT
            echo "‚ùå No image found for commit ${{ steps.prepare_deployment.outputs.head_sha }}"
          fi

      - name: üöÄ Deploy to Production (Build & Deploy)
        if: steps.check_changes.outputs.code_changed == 'true' || (steps.check_changes.outputs.code_changed == 'false' && steps.check_image.outputs.image_exists != 'true')
        run: |
          echo "üî® Building and deploying new code changes..."
          flyctl deploy --remote-only \
            --build-arg COMMIT_SHA=${{ steps.prepare_deployment.outputs.head_sha }} \
            --app ${{ steps.app_name.outputs.value }} \
            --strategy rolling \
            --max-unavailable 0.33 \
            --wait-timeout 5m \
            --yes

      - name: üöÄ Deploy to Production (Deploy Only)
        if: steps.check_changes.outputs.code_changed == 'false' && steps.check_image.outputs.image_exists == 'true'
        run: |
          echo "üì¶ Deploying existing image (no code changes)..."
          # Deploy the existing image without rebuilding
          flyctl deploy --image-label ${{ steps.prepare_deployment.outputs.head_sha }} \
            --app ${{ steps.app_name.outputs.value }} \
            --strategy rolling \
            --max-unavailable 0.33 \
            --wait-timeout 2m \
            --yes

      - name: Debug Slack Webhook URL
        run: |
          if [ -z "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
            echo "SLACK_WEBHOOK_URL secret is not available"
          else
            echo "SLACK_WEBHOOK_URL secret is available (length: ${#SLACK_WEBHOOK_URL})"
          fi
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify Slack of successful deployment to Production
        if: ${{ success() }}
        uses: slackapi/slack-github-action@v2.1.0
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          webhook-type: incoming-webhook
          payload: |
            {
              "text": "Deployment successful: main deployed to production by ${{ steps.prepare_deployment.outputs.actor }}\nApp: ${{ steps.app_name.outputs.value }}\nCommit: ${{ steps.prepare_deployment.outputs.head_sha }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Deployment successful*: `main` deployed to production by `${{ steps.prepare_deployment.outputs.actor }}`\n*App:* `${{ steps.app_name.outputs.value }}`\n*Commit:* <${{ github.server_url }}/${{ github.repository }}/commit/${{ steps.prepare_deployment.outputs.head_sha }}|${{ steps.prepare_deployment.outputs.head_sha }}>\n*Workflow:* <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ steps.prepare_deployment.outputs.workflow_run_id }}|View CI Run>"
                  }
                }
              ]
            }

      - name: Notify Slack of failed deployment to Production
        if: ${{ failure() }}
        uses: slackapi/slack-github-action@v2.1.0
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          webhook-type: incoming-webhook
          payload: |
            {
              "text": "Deployment failed: main deployment to production failed\nCommit: ${{ steps.prepare_deployment.outputs.head_sha }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Deployment failed*: `main` deployment to production failed\n*Commit:* <${{ github.server_url }}/${{ github.repository }}/commit/${{ steps.prepare_deployment.outputs.head_sha }}|${{ steps.prepare_deployment.outputs.head_sha }}>\n*Workflow:* <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Deployment Run>"
                  }
                }
              ]
            }
