# RBAC Implementation Plan - January 27, 2025

## Overview

This document outlines the implementation plan for the Role-Based Access Control (RBAC) system in Tournado. The RBAC utilities already exist in `app/utils/rbac.ts` but need to be integrated throughout the application.

## Current State Analysis

### Strengths of Target RBAC

-  Well-defined permission system with granular permissions
-  Role hierarchy (UNAUTHENTICATED ÔøΩ PUBLIC ÔøΩ REFEREE ÔøΩ MANAGER ÔøΩ ADMIN)
-  Comprehensive utility functions for permission checking
-  UI context switching between public/admin views

### Current Gap

The RBAC system exists but isn't integrated into routes, components, or business logic. Currently, all authenticated users are redirected to the admin panel regardless of their role.

### Existing Permissions Matrix

```typescript
const ROLE_PERMISSIONS: Record<Role | 'UNAUTHENTICATED', Permission[]> = {
   PUBLIC: ['teams:read', 'tournaments:read', 'matches:read'],
   REFEREE: ['teams:read', 'tournaments:read', 'matches:read', 'matches:referee'],
   REFEREE_COORDINATOR: [
      'teams:read',
      'tournaments:read',
      'matches:read',
      'matches:create',
      'matches:edit',
      'matches:referee',
   ],
   TOURNAMENT_MANAGER: [
      'teams:read',
      'teams:create',
      'teams:edit',
      'teams:delete',
      'tournaments:read',
      'tournaments:create',
      'tournaments:edit',
      'matches:read',
      'matches:create',
      'matches:edit',
   ],
   ADMIN: [
      'teams:read',
      'teams:create',
      'teams:edit',
      'teams:delete',
      'teams:manage',
      'tournaments:read',
      'tournaments:create',
      'tournaments:edit',
      'tournaments:delete',
      'tournaments:manage',
      'matches:read',
      'matches:create',
      'matches:edit',
      'matches:delete',
      'matches:referee',
   ],
   UNAUTHENTICATED: ['teams:read', 'tournaments:read', 'matches:read'],
}
```

## Implementation Plan

### Phase 0: Restructure Roles (High Priority)

**Timeline:** Week 1-2

- [ ] Remove REFEREE_COORDINATOR as a role
- [ ] Add 'matches:edit' role to REFEREE
- [ ] Rename TOURNAMENT_MANAGER to MANAGER
- [ ] Fix seeds accordingly

### Phase 1: Route-Level Protection (High Priority)

**Timeline:** Week 1-2

#### 1.1 Update Route Loaders/Actions

**Goal:** Replace current admin middleware with RBAC permission checks

**Tasks:**

- [ ] Add `requirePermission()` calls to route loaders and actions
- [ ] Implement role-based redirects instead of "all authenticated ‚Üí admin"
- [ ] Update authentication flow to redirect based on user role

**Affected Files:**

- [ ] `app/routes/a7k9m2x5p8w1n4q6r3y8b5t1/tournaments/**` - Require `tournaments:manage`
- [ ] `app/routes/a7k9m2x5p8w1n4q6r3y8b5t1/teams/**` - Require `teams:manage`
- [ ] `app/routes/auth/auth.signin.tsx` - Role-based redirect logic
- [ ] `app/root.tsx` - Update session handling

**Example Implementation:**

```typescript
// app/routes/a7k9m2x5p8w1n4q6r3y8b5t1/tournaments/new.tsx
export const loader = async ({ request }: LoaderArgs) => {
   const user = await getUser(request)
   requirePermission(user, 'tournaments:create')
   return {}
}
```

#### 1.2 Create RBAC Middleware

**Goal:** Create reusable middleware for permission checking

**Tasks:**

- [ ] Create `withPermissionCheck()` middleware wrapper
- [ ] Replace `withAdminRateLimit()` with role-aware rate limiting
- [ ] Add permission-based error responses

**New Files:**

- [ ] `app/utils/rbacMiddleware.server.ts` - Permission middleware
- [ ] `app/utils/roleBasedRedirects.ts` - Redirect logic based on roles

### Phase 2: Component-Level Access Control (High Priority)

**Timeline:** Week 3-4

#### 2.1 Navigation Updates

**Goal:** Show/hide navigation items based on user permissions

**Tasks:**

- [ ] Update `AdminLayout` to show/hide menu items based on permissions
- [ ] Implement `canAccess()` checks for navigation components
- [ ] Add role-based menu item filtering

**Affected Components:**

- [ ] `app/components/layouts/AdminLayout.tsx`
- [ ] `app/components/navigation/*`

**Example Implementation:**

```typescript
// In AdminLayout
const user = useUser()
const menuItems = [
   { path: '/tournaments', label: 'Tournaments', permission: 'tournaments:read' },
   { path: '/teams', label: 'Teams', permission: 'teams:read' },
].filter(item => canAccess(user, item.permission))
```

#### 2.2 Action Button Protection

**Goal:** Control access to Create/Edit/Delete actions

**Tasks:**

- [ ] Add permission checks to Create/Edit/Delete buttons
- [ ] Use `hasPermission()` for conditional rendering
- [ ] Implement graceful degradation for insufficient permissions

**Affected Components:**

- [ ] `app/components/ActionLinkButton.tsx`
- [ ] Tournament and Team management components
- [ ] Form components with action buttons

**Example Implementation:**

```typescript
// In TournamentsList component
const user = useUser()
const canCreateTournament = canAccess(user, 'tournaments:create')

return (
  <div>
    {canCreateTournament && (
      <ActionLinkButton to="new">Create Tournament</ActionLinkButton>
    )}
  </div>
)
```

### Phase 3: Business Logic Integration (Medium Priority)

**Timeline:** Month 2

#### 3.1 Data Access Control

**Goal:** Implement permission-based data filtering

**Tasks:**

- [ ] Implement permission checks in database queries
- [ ] Add role-based data filtering (e.g., REFEREE sees only assigned matches)
- [ ] Create role-specific loaders

**Areas of Focus:**

- [ ] Tournament data access
- [ ] Team management permissions
- [ ] Match assignment and referee access

#### 3.2 Form Access Control

**Goal:** Control form field access based on permissions

**Tasks:**

- [ ] Add permission-based form field enabling/disabling
- [ ] Implement role-specific form validation
- [ ] Create permission-aware form components

**Affected Areas:**

- [ ] Tournament creation/editing forms
- [ ] Team management forms
- [ ] User management forms

### Phase 4: User Management & Assignment (Medium Priority)

**Timeline:** Month 2-3

#### 4.1 User Role Management (ADMIN only)

**Goal:** Allow ADMINs to manage user roles

**Tasks:**

- [ ] Create user management interface
- [ ] Add role assignment functionality
- [ ] Implement user invitation system

**New Features:**

- [ ] User list with role display
- [ ] Role change interface
- [ ] User invitation workflow

#### 4.2 Referee Assignment (REFEREE)

**Goal:** Enable referee coordinators to assign referees to matches

**Tasks:**

- [ ] Create match assignment interface
- [ ] Add referee scheduling functionality
- [ ] Implement referee-specific dashboards

**New Features:**

- [ ] Match assignment dashboard
- [ ] Referee availability management
- [ ] Referee-specific match views

### Phase 5: Enhanced UI/UX (Low Priority)

**Timeline:** Month 3+

#### 5.1 Role-Based Dashboards

**Goal:** Provide tailored experiences for each role

**Tasks:**

- [ ] Create role-specific landing pages
- [ ] Implement permission-aware widgets
- [ ] Add role-based quick actions

**Role-Specific Features:**

- [ ] **ADMIN:** Full system overview and management
- [ ] **MANAGER:** Tournament-focused dashboard
- [ ] **REFEREE:** Referee and match management
- [ ] **PUBLIC:** Tournament viewing and team registration

#### 5.2 Progressive Disclosure

**Goal:** Show appropriate complexity based on user role

**Tasks:**

- [ ] Show appropriate complexity based on role
- [ ] Implement role-based feature discovery
- [ ] Add contextual help based on permissions

## Implementation Priority

### **Immediate (Week 1-2):**

1. [ ]  Route loader/action protection
2. [ ]  Basic navigation filtering
3. [ ]  Admin panel access control

### **Short-term (Week 3-4):**

1. [ ] Component-level permission checks
2. [ ] Role-based redirects after login
3. [ ] Permission-based button visibility

### **Medium-term (Month 2):**

1. [ ] User role management interface
2. [ ] Referee assignment functionality
3. [ ] Role-specific dashboards

### **Long-term (Month 3+):**

1. [ ] Advanced permission-based features
2. [ ] Audit logging for role changes
3. [ ] Role-based onboarding flows

## Testing Strategy

### Unit Tests

- [ ] Test RBAC utility functions with different user roles
- [ ] Verify permission matrix accuracy
- [ ] Test edge cases and invalid permissions

### Integration Tests

- [ ] Test route protection and component access
- [ ] Verify middleware functionality
- [ ] Test role-based redirects

### End-to-End Tests

- [ ] Test complete user journeys for each role
- [ ] Verify navigation and feature access
- [ ] Test role transitions and permission changes

### Security Tests

- [ ] Verify permission bypasses are impossible
- [ ] Test unauthorized access attempts
- [ ] Validate role escalation prevention

## Technical Considerations

### Migration Strategy

1. [ ] **Gradual Rollout:** Implement role checks alongside existing admin checks
2. [ ] **Feature Flags:** Use environment variables to toggle RBAC features
3. [ ] **Fallback Logic:** Maintain current admin access while implementing new roles

### Performance Implications

- [ ] Permission checks are lightweight utility functions
- [ ] Consider caching user permissions in session
- [ ] Minimize database queries for role verification

### Security Implications

- [ ] All permission checks must be server-side
- [ ] Client-side checks are for UX only, not security
- [ ] Implement defense-in-depth with multiple permission layers

## Success Metrics

### Functional Metrics

- [ ] All routes properly protected by appropriate permissions
- [ ] Navigation correctly filtered based on user roles
- [ ] Forms and actions respect permission boundaries

### User Experience Metrics

- [ ] Role-appropriate interfaces reduce confusion
- [ ] Users can accomplish their tasks efficiently
- [ ] Clear feedback when permissions are insufficient

### Security Metrics

- [ ] No unauthorized access to protected resources
- [ ] Permission violations properly logged and blocked
- [ ] Role boundaries effectively enforced

## Next Steps

1. [ ] **Start with Phase 1:** Begin implementing route-level protection
2. [ ] **Create Migration Plan:** Plan transition from current admin-only system
3. [ ] **Set Up Testing:** Establish test suite for RBAC functionality
4. [ ] **Documentation:** Update user guides for different roles

---

## FAQ: Common RBAC Implementation Questions

### Q: What happens if I add a new feature and forget to add it to RBAC?

**A:** Several serious security and usability issues will occur:

#### üö® Security Vulnerabilities

**1. Unauthorized Access**

- **All authenticated users** can access the new feature regardless of their role
- A REFEREE could access ADMIN-only functionality
- PUBLIC users might access sensitive management features

**2. Privilege Escalation**

- Users can perform actions beyond their intended permissions
- Could lead to data manipulation or deletion by unauthorized users
- Potential for accidental or malicious system damage

#### üîç What Would Happen in Practice

**Route-Level Issues:**

```typescript
// New feature route WITHOUT RBAC protection
export const loader = async ({ request }: LoaderArgs) => {
   // ‚ùå Missing: requirePermission(user, 'newfeature:read')
   const user = await getUser(request)

   // Anyone authenticated can access this!
   return await getNewFeatureData()
}
```

**Component-Level Issues:**

```typescript
// New action button WITHOUT permission check
function NewFeatureButton() {
  // ‚ùå Missing: canAccess(user, 'newfeature:create')

  // All users see this button regardless of role
  return <ActionLinkButton to="/new-feature/create">Create New Feature</ActionLinkButton>
}
```

**Navigation Issues:**

```typescript
// Admin menu WITHOUT role filtering
const menuItems = [
   { path: '/tournaments', permission: 'tournaments:read' },
   { path: '/teams', permission: 'teams:read' },
   // ‚ùå Missing permission check for new feature
   { path: '/new-feature', label: 'New Feature' },
]
```

#### üìä Impact Scenarios

**Scenario 1: New Admin Feature**

- **Intent**: Only ADMIN should access user management
- **Reality**: All authenticated users can manage other users
- **Risk**: Data breach, unauthorized user creation/deletion

**Scenario 2: New Referee Feature**

- **Intent**: Only REFEREE can submit match scores
- **Reality**: Anyone can submit/modify match results
- **Risk**: Tournament integrity compromised

**Scenario 3: New Public Feature**

- **Intent**: Enhanced team registration for PUBLIC users
- **Reality**: Works as intended (but still needs explicit permission)
- **Risk**: Lower, but inconsistent security model

#### üõ°Ô∏è Prevention Strategies

**1. Development Checklist**

```markdown
When adding new features:

- [ ] Define required permission in rbac.ts
- [ ] Add permission to appropriate roles
- [ ] Add requirePermission() to route loaders/actions
- [ ] Add canAccess() checks to components
- [ ] Update navigation permission filters
- [ ] Write tests for permission enforcement
```

**2. Code Review Requirements**

- [ ] **Mandatory RBAC review** for all new features
- [ ] **Security review** for permission matrix changes
- [ ] **Test coverage** for new permission combinations

**3. Automated Detection**

```typescript
// Lint rule idea: Detect routes without permission checks
// ESLint custom rule to flag missing requirePermission()
```

**4. Default Deny Approach**

```typescript
// Fail-safe: Default to most restrictive permission
const getRequiredPermission = (route: string): Permission => {
   const routePermissions = {
      '/tournaments': 'tournaments:read',
      '/teams': 'teams:read',
      // ... other routes
   }

   // ‚úÖ Default to admin-only for unmapped routes
   return routePermissions[route] || 'admin:access'
}
```

#### üîß Recommended Safeguards

**1. RBAC Integration Testing**

```typescript
// Test that runs after each deployment
describe('RBAC Coverage', () => {
   test('all routes have permission requirements', () => {
      const routes = getAllRoutes()
      routes.forEach(route => {
         expect(route).toHavePermissionCheck()
      })
   })
})
```

**2. Permission Audit Script**

```bash
# Check for routes without RBAC
grep -r "export const loader" app/routes/ | grep -v "requirePermission"
```

**3. Feature Flag Integration**

```typescript
// New features behind feature flags with RBAC
if (isFeatureEnabled('newFeature') && hasPermission(user, 'newfeature:access')) {
   // Show new feature
}
```

#### üìã Quick Fix Process

If you discover an unprotected feature:

1. [ ] **Immediate**: Add permission check to route loader
2. [ ] **Short-term**: Add component-level checks
3. [ ] **Long-term**: Add comprehensive tests
4. [ ] **Review**: Audit similar features for gaps

**Key takeaway:** Make RBAC checks a **mandatory part of the development workflow** rather than an afterthought.

---

**Note:** This implementation plan builds on the existing RBAC utilities in `app/utils/rbac.ts` and integrates them throughout the application to provide proper role-based access control as outlined in the PRD.
