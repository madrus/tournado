---
description: Architectural Decision Records
globs:
alwaysApply: false
---

# Architecture Decision Records

<!--
ADR_AGENT_PROTOCOL v1.0

You (the agent) manage this file as the single source of truth for all ADRs.

INVARIANTS
- Keep this exact file structure and headings.
- All ADR entries use H2 headings: "## ADR-XXXX — <Title>" (4-digit zero-padded ID).
- Allowed Status values: Proposed | Accepted | Superseded
- Date format: YYYY-MM-DD
- New entries must be appended to the END of the file.
- The Index table between the INDEX markers must always reflect the latest state and be sorted by ID desc (newest on top).
- Each ADR MUST contain: Date, Status, Owner, Context, Decision, Consequences.
- Each ADR must include an explicit anchor `<a id="adr-XXXX"></a>` so links remain stable.

HOW TO ADD A NEW ADR
1) Read the whole file.
2) Compute next ID:
   - Scan for headings matching: ^## ADR-(\d{4}) — .+$
   - next_id = (max captured number) + 1, left-pad to 4 digits.
3) Create a new ADR section using the “New ADR Entry Template” below.
   - Place it AFTER the last ADR section in the file.
   - Add an `<a id="adr-XXXX"></a>` line immediately below the heading.
4) Update the Index (between the INDEX markers):
   - Insert/replace the row for this ADR keeping the table sorted by ID descending.
   - Title in the Index MUST link to the anchor: [<Title>](#adr-XXXX)
   - If this ADR supersedes another: set “Supersedes” in this row, and update that older ADR:
       a) Change its Status to “Superseded”
       b) Add “Superseded by: ADR-XXXX” in its Consequences block
       c) Update the older ADR’s Index row “Superseded by” column to ADR-XXXX
5) Validate before saving:
   - Exactly one heading exists for ADR-XXXX
   - All required fields are present and non-empty
   - Index contains a row for ADR-XXXX and remains properly sorted
6) Concurrency resolution:
   - If a merge conflict or duplicate ID is detected after reading: recompute next_id from the current file state, rename your heading, anchor, and Index row accordingly, and retry once.

COMMIT MESSAGE SUGGESTION
- "ADR-XXXX: <Short Title> — <Status>"

END ADR_AGENT_PROTOCOL
-->

## Index

<!-- BEGIN:ADR_INDEX -->

| ID   | Title                                                        | Date       | Status   | Supersedes | Superseded by |
| ---- | ------------------------------------------------------------ | ---------- | -------- | ---------- | ------------- |
| 0004 | [State Management with Zustand and React Router Loaders](#adr-0004) | 2025-01-27 | Accepted | —          | —             |
| 0002 | [Single Repository Frontend-Only Architecture](#adr-0002)    | 2025-01-27 | Accepted | —          | —             |
| 0001 | [React Router v7 Frontend Architecture](#adr-0001)       | 2025-01-27 | Accepted | —          | —             |

<!-- END:ADR_INDEX -->

---

## New ADR Entry Template (copy for each new decision)

> Replace placeholders, keep section headers. Keep prose concise.

```

## ADR-XXXX — \<Short, specific title>

<a id="adr-XXXX"></a>
**Date**: YYYY-MM-DD
**Status**: Proposed | Accepted | Superseded
**Owner**: <Name>

### Context

<1–3 sentences: what changed or what forces drive this decision now>

### Alternatives

<Quick bullet list of alternatives considered, and why they were rejected.>

### Decision

\<Single clear decision in active voice; make it testable/verifiable>

### Consequences

* **Pros**: \<benefit 1>, \<benefit 2>
* **Cons / risks**: \<cost 1>, \<risk 1>
* **Supersedes**: ADR-NNNN (if any)
* **Superseded by**: ADR-MMMM (filled later if replaced)

### (Optional) Compliance / Verification

\<How we’ll check this is honored: tests, checks, fitness functions, runbooks>

```

---

## ADR-0001 — React Router v7 Frontend Architecture

<a id="adr-0001"></a>
**Date**: 2025-01-27 
**Status**: Accepted
**Owner**: AI Agent

### Context

Modern tournament management applications require responsive, offline-capable frontend experiences with efficient data management. React Router v7 provides full-stack capabilities with SSR, while Prisma and SQLite offer robust data persistence without backend complexity.

### Alternatives

- **Create React App**: Basic setup but lacks SSR and advanced routing capabilities
- **Next.js**: Full-stack but adds unnecessary complexity for frontend-focused applications
- **Vite + React Router (classic)**: Client-side only, missing SSR benefits
- **React Router v7**: Modern full-stack React framework with file-based routing and SSR

### Decision

Create a comprehensive React Router v7 frontend architecture with:

- React Router v7 with file-based routing and SSR
- TypeScript for type safety throughout the application
- Prisma ORM with SQLite for data persistence
- Tailwind CSS for responsive, mobile-first design
- Vite as build tool for optimal performance
- Zustand for client-side state management

### Consequences

- **Pros**: Modern React patterns, excellent performance, simplified architecture, type-safe development
- **Cons / risks**: Relatively new framework, fewer third-party integrations, learning curve for team
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

Template includes working examples for routing, data loading, and state management. Development workflow optimized for React Router v7 patterns. Testing strategy covers both unit and E2E scenarios.

---

## ADR-0002 — Single Repository Frontend-Only Architecture

<a id="adr-0002"></a>
**Date**: 2025-01-27
**Status**: Accepted
**Owner**: AI Agent

### Context

Tournament management applications can be effectively built as frontend-only applications using React Router v7's full-stack capabilities. The decision was how to structure the codebase to maximize development efficiency while maintaining clear organization.

### Alternatives

- **Monorepo with separate frontend/backend**: Unnecessary complexity for frontend-only architecture
- **Nested component directories**: Harder to navigate and maintain as application grows
- **Single repository with feature-based organization**: Clean structure optimized for React Router v7

### Decision

Implement single repository structure optimized for React Router v7:

- `/app/` - Main application code with routes, components, and utilities
- `/app/routes/` - File-based routing structure following React Router v7 conventions
- `/app/components/` - Reusable UI components organized by domain
- `/prisma/` - Database schema and migrations
- Root-level configuration files (Vite, Tailwind, TypeScript, etc.)
- `/docs/` - Comprehensive documentation system

### Consequences

- **Pros**: Simplified development workflow, single deployment target, clear React Router patterns, easier maintenance
- **Cons / risks**: All code in single repository, potential for large bundle sizes without proper code splitting
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

Directory structure follows React Router v7 conventions. Build system optimized for single-page application deployment. Documentation covers development patterns and best practices.

---

## ADR-0004 — State Management with Zustand and React Router Loaders

<a id="adr-0004"></a>
**Date**: 2025-01-27
**Status**: Accepted
**Owner**: AI Agent

### Context

Frontend applications need efficient state management that works well with React Router v7's data loading patterns. The challenge is balancing server-side data loading with client-side state management while maintaining type safety and performance.

### Alternatives

- **Redux Toolkit**: Comprehensive but adds complexity and boilerplate for frontend-only applications
- **React Context only**: Simple but can cause performance issues with large state trees
- **SWR/React Query**: Great for server state but requires separate client state solution
- **Zustand with React Router loaders**: Lightweight client state with built-in server data management

### Decision

Implement hybrid state management combining Zustand for client state with React Router loaders for server data:

- React Router loaders handle all server data fetching and caching
- Zustand stores manage client-only state (UI state, user preferences, temporary data)
- Server state flows through React Router's built-in data loading mechanisms
- Client state persists using Zustand's persistence middleware where appropriate
- Type-safe state management throughout the application

### Consequences

- **Pros**: Optimal performance, minimal boilerplate, leverages React Router's caching, type-safe state management, clear separation between server and client state
- **Cons / risks**: Learning curve for developers familiar with Redux, need to understand React Router data patterns, potential over-fetching without careful loader design
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

Server data must flow through React Router loaders and actions. Client state management uses Zustand with proper TypeScript interfaces. No direct API calls from components except through loader/action patterns. State persistence configured only for appropriate client state.

---
